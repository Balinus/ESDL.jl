<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis · CABLAB.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script></head><body><nav class="toc"><h1>CABLAB.jl</h1><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="thecube.html">The CABLAB Data Cube</a></li><li><a class="toctext" href="cube_access.html">Accessing the Datat Cube</a></li><li class="current"><a class="toctext" href="analysis.html">Analysis</a><ul class="internal"><li><a class="toctext" href="#Seasonal-cycles-1">Seasonal cycles</a></li><li><a class="toctext" href="#Outlier-detection-1">Outlier detection</a></li><li><a class="toctext" href="#Simple-Statistics-1">Simple Statistics</a></li><li><a class="toctext" href="#Time-series-decomposition-1">Time series decomposition</a></li><li><a class="toctext" href="#Cube-transformations-1">Cube transformations</a></li></ul></li><li><a class="toctext" href="plotting.html">Plotting</a></li><li><a class="toctext" href="adding_new.html">Applying custom functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="analysis.html">Analysis</a></li></ul><a class="edit-page" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/docs/src/analysis.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Analysis-1" href="#Analysis-1">Analysis</a></h1><p>The CABLAB package comes with a list of predefined methods for statistical analysis. The functions are defined to work on specific axes, for example a function that removes the mean annual cycle will alway work an the time axis. It does not matter which other axes are defined in the input cube, the function will simply loop over these. All the functions are called using the <code>mapCube</code> function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.DAT.mapCube" href="#CABLAB.DAT.mapCube"><code>CABLAB.DAT.mapCube</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mapCube(fun, cube, addargs...;kwargs)</code></pre><p>Map a given function <code>fun</code> over slices of the data cube <code>cube</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>max_cache=1e7</code> maximum size of blocks that are read into memory, defaults to approx 10Mb</p></li><li><p><code>outfolder</code> folder to write output to if a <code>TempCube is created</code>, defaults to <code>joinpath(CABLABdir(),&quot;tmp&quot;,SomeRandomName)</code></p></li><li><p><code>outtype::DataType</code> output data type of the operation</p></li><li><p><code>indims::Tuple{Tuple{Vararg{CubeAxis}}}</code> List of input axis types for each input data cube</p></li><li><p><code>outdims::Tuple</code> List of output axes, can be either an axis type that has a default constructor or an instance of a <code>CubeAxis</code></p></li><li><p><code>inmissing::Tuple</code> How to treat missing values in input data for each input cube. Possible values are <code>:nullable</code> <code>:mask</code> <code>:nan</code> or a value that is inserted for missing data, defaults to <code>:mask</code></p></li><li><p><code>outmissing</code> How are missing values written to the output array, possible values are <code>:nullable</code>, <code>:mask</code>, <code>:nan</code>, defaults to <code>:mask</code></p></li><li><p><code>no_ocean</code> should values containing ocean data be omitted</p></li><li><p><code>inplace</code> does the function write to an output array inplace or return a single value&gt; defaults to <code>true</code></p></li><li><p><code>kwargs</code> additional keyword arguments passed to the inner function</p></li></ul><p>The first argument is always the function to be applied, the second is the input cube or a tuple input cubes if needed. If the function to be applied is registered (either as part of CABLAB or through <a href="adding_new.html#registerDATFunction-1">registerDATFunction</a>), all of the keyword arguments have reasonable defaults and don&#39;t need to be supplied. Some of the function still need additional arguments or keyword arguments as is stated in the documentation.</p><p>If you want to call mapCube directly on an unregistered function, please have a look at <a href="adding_new.html#Applying-custom-functions-1">Applying custom functions</a> to get an idea about the usage of the input and output dimensions etc.</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/DAT/DAT.jl#L181-L206">source</a><br/></section><p>The function will then be applied to the whole cube in a memory-efficient way, which means that chunks of data are read, processed and then saved in the output cube. Whether the output cube is a <code>TempCube</code> or a <code>CubeMem</code> is decided by the system, depending on if the calculation is parallel, and how large the output cube is.</p><p>Here follows a list of analysis function included in this package. If you have implemented or wrapped a method that might be of interest to a broader community, please feel free to open a pull request.</p><h2><a class="nav-anchor" id="Seasonal-cycles-1" href="#Seasonal-cycles-1">Seasonal cycles</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.MSC.gapFillMSC-Tuple{AbstractArray,AbstractArray{UInt8,N},AbstractArray,AbstractArray{UInt8,N},Integer,Any,Any}" href="#CABLAB.Proc.MSC.gapFillMSC-Tuple{AbstractArray,AbstractArray{UInt8,N},AbstractArray,AbstractArray{UInt8,N},Integer,Any,Any}"><code>CABLAB.Proc.MSC.gapFillMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gapFillMSC</code></pre><p>Fills missing values of each time series with the mean annual cycle.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(gapFillMSC, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/Proc/MSC.jl#L37-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.MSC.getMSC" href="#CABLAB.Proc.MSC.getMSC"><code>CABLAB.Proc.MSC.getMSC</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getMSC</code></pre><p>Returns the mean annual cycle from each time series.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(getMSC, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>MSC</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/Proc/MSC.jl#L65-L80">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.MSC.getMedSC-Tuple{AbstractArray{T,1},AbstractArray{UInt8,1},AbstractArray{T,1},AbstractArray{UInt8,1}}" href="#CABLAB.Proc.MSC.getMedSC-Tuple{AbstractArray{T,1},AbstractArray{UInt8,1},AbstractArray{T,1},AbstractArray{UInt8,1}}"><code>CABLAB.Proc.MSC.getMedSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getMedMSC</code></pre><p>Returns the median annual cycle from each time series.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(getMedMSC, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>MSC</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/Proc/MSC.jl#L116-L131">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.MSC.removeMSC-Tuple{AbstractArray,AbstractArray{UInt8,N},AbstractArray,AbstractArray{UInt8,N},Integer,Any,Any}" href="#CABLAB.Proc.MSC.removeMSC-Tuple{AbstractArray,AbstractArray{UInt8,N},AbstractArray,AbstractArray{UInt8,N},Integer,Any,Any}"><code>CABLAB.Proc.MSC.removeMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">removeMSC</code></pre><p>Removes the mean annual cycle from each time series.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(removeMSC, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/Proc/MSC.jl#L8-L23">source</a><br/></section><h2><a class="nav-anchor" id="Outlier-detection-1" href="#Outlier-detection-1">Outlier detection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.Outlier.DAT_detectAnomalies!-Tuple{AbstractArray,AbstractArray,MultivariateAnomalies.PARAMS}" href="#CABLAB.Proc.Outlier.DAT_detectAnomalies!-Tuple{AbstractArray,AbstractArray,MultivariateAnomalies.PARAMS}"><code>CABLAB.Proc.Outlier.DAT_detectAnomalies!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">DAT_detectAnomalies!</code></pre><p>A simple wrapper around the function <code>detectAnomalies!</code> from the <a href="https://github.com/milanflach/MultivariateAnomalies.jl">MultivariateAnomalies</a> package.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(DAT_detectAnomalies!, cube, methods, trainArray)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code>, <code>VariableAxis</code></p></li><li><p><code>methods</code> vector of methods to be applied, choose from: <code>KDE</code>,<code>T2</code>,<code>REC</code>,<code>KNN-Gamma</code>,<code>KNN-Delta</code>,<code>SVDD</code>,<code>KNFST</code></p></li><li><p><code>trainArray</code> a matrix of <code>nsample</code> x <code>nvar</code>, to estimate the training parameters for the model. Ideally does not contain any extreme values</p></li></ul><p><strong>Input Axes</strong> <code>TimeAxis</code>, <code>Variable</code>axis</p><p><strong>Output Axes</strong> <code>TimeAxis</code>, <code>Method</code>axis</p><p>For an example on how to apply this function, see <a href="https://github.com/CAB-LAB/JuliaDatDemo/blob/master/eventdetection2.ipynb">this notebook</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/Proc/Outlier.jl#L15-L34">source</a><br/></section><h2><a class="nav-anchor" id="Simple-Statistics-1" href="#Simple-Statistics-1">Simple Statistics</a></h2><p>Another typcial use case is the application of basic statistics like <code>sum</code>, <code>mean</code> and <code>std</code>. We provide a convenience function <code>reduceCube</code>  </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.DAT.reduceCube" href="#CABLAB.DAT.reduceCube"><code>CABLAB.DAT.reduceCube</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reduceCube(f::Function, cube, dim::Type{T&lt;:CubeAxis};kwargs...)</code></pre><p>Apply a reduction function <code>f</code> on slices of the cube <code>cube</code>. The dimension(s) are specified through <code>dim</code>, which is either an Axis type or a tuple of axis types. Keyword arguments are passed to <code>mapCube</code> or, if unknown passed again to <code>f</code>. It is assumed that <code>f</code> takes an array input and returns a single value.</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/DAT/DAT.jl#L156-L162">source</a><br/></section><p>Additional simple statistics functions are:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.Stats.normalizeTS-Tuple{AbstractArray{T,1},AbstractArray{T,1}}" href="#CABLAB.Proc.Stats.normalizeTS-Tuple{AbstractArray{T,1},AbstractArray{T,1}}"><code>CABLAB.Proc.Stats.normalizeTS</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">normalizeTS</code></pre><p>Normalize a time series to zeros mean and unit variance</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(normalizeTS, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>TimeAxis</code></p><p><strong>Output Axes</strong> <code>TimeAxis</code></p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/Proc/Stats.jl#L10-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.Stats.timespacequantiles-Tuple{AbstractArray{T,1},AbstractArray,AbstractArray{T,1},Any}" href="#CABLAB.Proc.Stats.timespacequantiles-Tuple{AbstractArray{T,1},AbstractArray,AbstractArray{T,1},Any}"><code>CABLAB.Proc.Stats.timespacequantiles</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">timespacequantiles</code></pre><p>Calculate quantiles from a space time data cube. This is usually called on a subset of data returned by <a href="@ref"><code>sampleLandPoints</code></a>.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(timespacequantiles, cube, quantiles)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code>, <code>SpatialPointAxis</code></p></li><li><p><code>quantiles</code> a vector of quantile values to calculate</p></li></ul><p><strong>Input Axes</strong> <code>TimeAxis</code>, <code>SpatialPointAxis</code></p><p><strong>Output Axes</strong> <code>QuantileAxis</code></p><p>Calculating exact quantiles from data that don&#39;t fit into memory is quite a problem. One solution we provide here is to simply subsample your data and then get the quantiles from a smaller dataset.</p><p>For an example on how to apply this function, see <a href="https://github.com/CAB-LAB/JuliaDatDemo/blob/master/eventdetection2.ipynb">this notebook</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/Proc/Stats.jl#L34-L55">source</a><br/></section><h2><a class="nav-anchor" id="Time-series-decomposition-1" href="#Time-series-decomposition-1">Time series decomposition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.TSDecomposition.filterTSFFT-Tuple{Array{T<:Real,2},Array{T<:Real,1},Number}" href="#CABLAB.Proc.TSDecomposition.filterTSFFT-Tuple{Array{T<:Real,2},Array{T<:Real,1},Number}"><code>CABLAB.Proc.TSDecomposition.filterTSFFT</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">filterTSFFT</code></pre><p>Filter each time series using a Fourier filter and return the decomposed series in 4 time windows (Trend, Long-Term Variability, Annual Cycle, Fast Oscillations)</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(filterTSFFT, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis, <code>TimeScale</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/35f9a75d0540d7a2245cd45681ab1497a75ec649/src/Proc/TSDecomposition.jl#L22-L38">source</a><br/></section><h2><a class="nav-anchor" id="Cube-transformations-1" href="#Cube-transformations-1">Cube transformations</a></h2><footer><hr/><a class="previous" href="cube_access.html"><span class="direction">Previous</span><span class="title">Accessing the Datat Cube</span></a><a class="next" href="plotting.html"><span class="direction">Next</span><span class="title">Plotting</span></a></footer></article></body></html>
