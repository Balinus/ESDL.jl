<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis · CABLAB.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="CABLAB.jl logo"/></a><h1>CABLAB.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="thecube.html">The CABLAB Data Cube</a></li><li><a class="toctext" href="cube_access.html">Accessing the Data Cube</a></li><li class="current"><a class="toctext" href="analysis.html">Analysis</a><ul class="internal"><li><a class="toctext" href="#Seasonal-cycles-1">Seasonal cycles</a></li><li><a class="toctext" href="#Outlier-detection-1">Outlier detection</a></li><li><a class="toctext" href="#Simple-Statistics-1">Simple Statistics</a></li><li><a class="toctext" href="#Time-series-decomposition-1">Time series decomposition</a></li><li><a class="toctext" href="#Cube-transformations-1">Cube transformations</a></li><li><a class="toctext" href="#OnlineStats-1">OnlineStats</a></li></ul></li><li><a class="toctext" href="plotting.html">Plotting</a></li><li><a class="toctext" href="adding_new.html">Applying custom functions</a></li><li><a class="toctext" href="iotools.html">Loading and saving results</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="analysis.html">Analysis</a></li></ul><a class="edit-page" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/docs/src/analysis.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Analysis-1" href="#Analysis-1">Analysis</a></h1><p>The CABLAB package comes with a list of predefined methods for statistical analysis. The functions are defined to work on specific axes, for example a function that removes the mean annual cycle will alway work an the time axis. It does not matter which other axes are defined in the input cube, the function will simply loop over these. All the functions are called using the <code>mapCube</code> function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.DAT.mapCube" href="#CABLAB.DAT.mapCube"><code>CABLAB.DAT.mapCube</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mapCube(fun, cube, addargs...;kwargs)</code></pre><p>Map a given function <code>fun</code> over slices of the data cube <code>cube</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>max_cache=1e7</code> maximum size of blocks that are read into memory, defaults to approx 10Mb</p></li><li><p><code>outtype::DataType</code> output data type of the operation</p></li><li><p><code>indims::Tuple{Tuple{Vararg{CubeAxis}}}</code> List of input axis types for each input data cube</p></li><li><p><code>outdims::Tuple</code> List of output axes, can be either an axis type that has a default constructor or an instance of a <code>CubeAxis</code></p></li><li><p><code>inmissing::Tuple</code> How to treat missing values in input data for each input cube. Possible values are <code>:nullable</code> <code>:mask</code> <code>:nan</code> or a value that is inserted for missing data, defaults to <code>:mask</code></p></li><li><p><code>outmissing</code> How are missing values written to the output array, possible values are <code>:nullable</code>, <code>:mask</code>, <code>:nan</code>, defaults to <code>:mask</code></p></li><li><p><code>no_ocean</code> should values containing ocean data be omitted, an integer specifying the cube whose input mask is used to determine land-sea points.</p></li><li><p><code>inplace</code> does the function write to an output array inplace or return a single value&gt; defaults to <code>true</code></p></li><li><p><code>ispar</code> boolean to determine if parallelisation should be applied, defaults to <code>true</code> if workers are available.</p></li><li><p><code>kwargs</code> additional keyword arguments passed to the inner function</p></li></ul><p>The first argument is always the function to be applied, the second is the input cube or a tuple input cubes if needed. If the function to be applied is registered (either as part of CABLAB or through <a href="adding_new.html#registerDATFunction-1">registerDATFunction</a>), all of the keyword arguments have reasonable defaults and don&#39;t need to be supplied. Some of the function still need additional arguments or keyword arguments as is stated in the documentation.</p><p>If you want to call mapCube directly on an unregistered function, please have a look at <a href="adding_new.html#Applying-custom-functions-1">Applying custom functions</a> to get an idea about the usage of the input and output dimensions etc.</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/DAT/DAT.jl#L212-L237">source</a><br/></section><p>The function will then be applied to the whole cube in a memory-efficient way, which means that chunks of data are read, processed and then saved in the output cube. Whether the output cube is a <code>TempCube</code> or a <code>CubeMem</code> is decided by the system, depending on if the calculation is parallel, and how large the output cube is.</p><p>Here follows a list of analysis function included in this package. If you have implemented or wrapped a method that might be of interest to a broader community, please feel free to open a pull request.</p><h2><a class="nav-anchor" id="Seasonal-cycles-1" href="#Seasonal-cycles-1">Seasonal cycles</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.MSC.gapFillMSC-Tuple{AbstractArray,AbstractArray{UInt8,N},AbstractArray,AbstractArray{UInt8,N},Integer,Any,Any}" href="#CABLAB.Proc.MSC.gapFillMSC-Tuple{AbstractArray,AbstractArray{UInt8,N},AbstractArray,AbstractArray{UInt8,N},Integer,Any,Any}"><code>CABLAB.Proc.MSC.gapFillMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gapFillMSC</code></pre><p>Fills missing values of each time series with the mean annual cycle.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(gapFillMSC, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/MSC.jl#L37-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.MSC.getMSC" href="#CABLAB.Proc.MSC.getMSC"><code>CABLAB.Proc.MSC.getMSC</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getMSC</code></pre><p>Returns the mean annual cycle from each time series.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(getMSC, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>MSC</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/MSC.jl#L65-L80">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.MSC.getMedSC-Tuple{AbstractArray{T,1},AbstractArray{UInt8,1},AbstractArray{T,1},AbstractArray{UInt8,1}}" href="#CABLAB.Proc.MSC.getMedSC-Tuple{AbstractArray{T,1},AbstractArray{UInt8,1},AbstractArray{T,1},AbstractArray{UInt8,1}}"><code>CABLAB.Proc.MSC.getMedSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getMedMSC</code></pre><p>Returns the median annual cycle from each time series.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(getMedMSC, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>MSC</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/MSC.jl#L115-L130">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.MSC.removeMSC-Tuple{AbstractArray,AbstractArray{UInt8,N},AbstractArray,AbstractArray{UInt8,N},Integer,Any,Any}" href="#CABLAB.Proc.MSC.removeMSC-Tuple{AbstractArray,AbstractArray{UInt8,N},AbstractArray,AbstractArray{UInt8,N},Integer,Any,Any}"><code>CABLAB.Proc.MSC.removeMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">removeMSC</code></pre><p>Removes the mean annual cycle from each time series.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(removeMSC, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/MSC.jl#L8-L23">source</a><br/></section><h2><a class="nav-anchor" id="Outlier-detection-1" href="#Outlier-detection-1">Outlier detection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.Outlier.DAT_detectAnomalies!-Tuple{AbstractArray,AbstractArray,MultivariateAnomalies.PARAMS}" href="#CABLAB.Proc.Outlier.DAT_detectAnomalies!-Tuple{AbstractArray,AbstractArray,MultivariateAnomalies.PARAMS}"><code>CABLAB.Proc.Outlier.DAT_detectAnomalies!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">DAT_detectAnomalies!</code></pre><p>A simple wrapper around the function <code>detectAnomalies!</code> from the <a href="https://github.com/milanflach/MultivariateAnomalies.jl">MultivariateAnomalies</a> package.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(DAT_detectAnomalies!, cube, methods, trainArray)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code>, <code>VariableAxis</code></p></li><li><p><code>methods</code> vector of methods to be applied, choose from: <code>KDE</code>,<code>T2</code>,<code>REC</code>,<code>KNN-Gamma</code>,<code>KNN-Delta</code>,<code>SVDD</code>,<code>KNFST</code></p></li><li><p><code>trainArray</code> a matrix of <code>nsample</code> x <code>nvar</code>, to estimate the training parameters for the model. Ideally does not contain any extreme values</p></li></ul><p><strong>Input Axes</strong> <code>TimeAxis</code>, <code>Variable</code>axis</p><p><strong>Output Axes</strong> <code>TimeAxis</code>, <code>Method</code>axis</p><p>For an example on how to apply this function, see <a href="https://github.com/CAB-LAB/JuliaDatDemo/blob/master/eventdetection2.ipynb">this notebook</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/Outlier.jl#L15-L34">source</a><br/></section><h2><a class="nav-anchor" id="Simple-Statistics-1" href="#Simple-Statistics-1">Simple Statistics</a></h2><p>Another typcial use case is the application of basic statistics like <code>sum</code>, <code>mean</code> and <code>std</code>. We provide a convenience function <code>reduceCube</code>  </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.DAT.reduceCube" href="#CABLAB.DAT.reduceCube"><code>CABLAB.DAT.reduceCube</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reduceCube(f::Function, cube, dim::Type{T&lt;:CubeAxis};kwargs...)</code></pre><p>Apply a reduction function <code>f</code> on slices of the cube <code>cube</code>. The dimension(s) are specified through <code>dim</code>, which is either an Axis type or a tuple of axis types. Keyword arguments are passed to <code>mapCube</code> or, if unknown passed again to <code>f</code>. It is assumed that <code>f</code> takes an array input and returns a single value.</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/DAT/DAT.jl#L187-L193">source</a><br/></section><p>Applying these functions makes sense if the slices one wants to reduce fit in memory. However, if one wants to calculate some statistics on e.g. a time<em>lon</em>lat cube, one would preferably call one of the <a href="analysis.html#OnlineStats-1">OnlineStats</a> methods.  </p><p>Additional simple statistics functions are:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.Stats.normalizeTS-Tuple{AbstractArray{T,1},AbstractArray{T,1}}" href="#CABLAB.Proc.Stats.normalizeTS-Tuple{AbstractArray{T,1},AbstractArray{T,1}}"><code>CABLAB.Proc.Stats.normalizeTS</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">normalizeTS</code></pre><p>Normalize a time series to zeros mean and unit variance</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(normalizeTS, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>TimeAxis</code></p><p><strong>Output Axes</strong> <code>TimeAxis</code></p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/Stats.jl#L10-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.Stats.timespacequantiles-Tuple{AbstractArray{T,1},AbstractArray,AbstractArray{T,1},Any}" href="#CABLAB.Proc.Stats.timespacequantiles-Tuple{AbstractArray{T,1},AbstractArray,AbstractArray{T,1},Any}"><code>CABLAB.Proc.Stats.timespacequantiles</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">timespacequantiles</code></pre><p>Calculate quantiles from a space time data cube. This is usually called on a subset of data returned by <a href="@ref">sampleLandPoints</a>.</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(timespacequantiles, cube, quantiles)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code>, <code>SpatialPointAxis</code></p></li><li><p><code>quantiles</code> a vector of quantile values to calculate</p></li></ul><p><strong>Input Axes</strong> <code>TimeAxis</code>, <code>SpatialPointAxis</code></p><p><strong>Output Axes</strong> <code>QuantileAxis</code></p><p>Calculating exact quantiles from data that don&#39;t fit into memory is quite a problem. One solution we provide here is to simply subsample your data and then get the quantiles from a smaller dataset.</p><p>For an example on how to apply this function, see <a href="https://github.com/CAB-LAB/JuliaDatDemo/blob/master/eventdetection2.ipynb">this notebook</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/Stats.jl#L39-L60">source</a><br/></section><h2><a class="nav-anchor" id="Time-series-decomposition-1" href="#Time-series-decomposition-1">Time series decomposition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.TSDecomposition.filterTSFFT-Tuple{Array{T&lt;:Real,2},Array{T&lt;:Real,1},Number}" href="#CABLAB.Proc.TSDecomposition.filterTSFFT-Tuple{Array{T&lt;:Real,2},Array{T&lt;:Real,1},Number}"><code>CABLAB.Proc.TSDecomposition.filterTSFFT</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">filterTSFFT</code></pre><p>Filter each time series using a Fourier filter and return the decomposed series in 4 time windows (Trend, Long-Term Variability, Annual Cycle, Fast Oscillations)</p><p><strong>Call signature</strong></p><pre><code class="language-none">mapCube(filterTSFFT, cube)</code></pre><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code></p></li></ul><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis, <code>TimeScale</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/TSDecomposition.jl#L22-L38">source</a><br/></section><h2><a class="nav-anchor" id="Cube-transformations-1" href="#Cube-transformations-1">Cube transformations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.CubeIO.extractLonLats-Tuple{CABLAB.Cubes.AbstractCubeData,Array{T,2}}" href="#CABLAB.Proc.CubeIO.extractLonLats-Tuple{CABLAB.Cubes.AbstractCubeData,Array{T,2}}"><code>CABLAB.Proc.CubeIO.extractLonLats</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">extractLonLats(c::AbstractCubeData,pl::Matrix)</code></pre><p>Extracts a list of longitude/latitude coordinates from a data cube. The coordinates are specified through the matrix <code>pl</code> where <code>size(pl)==(N,2)</code> and N is the number of extracted coordinates. Returns a data cube without <code>LonAxis</code> and <code>LatAxis</code> but with a <code>SpatialPointAxis</code> containing the input locations. </p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/CubeIO.jl#L66-L73">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.CubeIO.sampleLandPoints" href="#CABLAB.Proc.CubeIO.sampleLandPoints"><code>CABLAB.Proc.CubeIO.sampleLandPoints</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sampleLandPoints(cube, nsample;nomissing=false)</code></pre><p>Get an area-weighted sample from all non-ocean grid cells. This will return a new Cube where the <code>LonAxis</code> and <code>LatAxis</code> are condensed into a single <code>SpatialPointAxis</code> of length <code>nsample</code>. If <code>nomissing=true</code> only grid cells will be selected which don&#39;t contain any missing values. This makes sense for gap-filled cubes to make sure that grid cells with systematic seasonal gaps are not selected in the sample.</p></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/CubeIO.jl#L88-L96">source</a><br/></section><h2><a class="nav-anchor" id="OnlineStats-1" href="#OnlineStats-1">OnlineStats</a></h2><p>It is possible to directly apply statistics included in the <a href="https://github.com/joshday/OnlineStats.jl">OnlineStats.jl package</a> on the data cube. This makes it possible to calculate statistics on data too big to fit into memory. The general syntax is</p><pre><code class="language-none">mapCube(f ,cube; by=CubeAxis[], cfun=identity, outAxis=nothing,kwargs...)</code></pre><p>where <code>f</code> is an OnlineStat data type and <code>cube</code> is the cube you want to apply the statistics to. By default this function will reduce all values over all axes of the cube, so if you want to do statistics by a certain axis, it has to be specified using the <code>by</code> keyword argument. <code>by</code> accepts a vector of axes types and up to one datacube that can serve as a mask. If such a data cube is supplied, the statistics are split by the unique values in the mask. One can pass a function <code>cfun</code> that transforms the mask values into an index in the range <code>1..N</code> that defines the    index where the new value is going to be put to. If a mask is supplied, it must have either a <code>labels</code> property, which is a <code>Dict{T,String}</code> mapping the numerical mask value to the value name. Alternatively on can supply an <code>outAxis</code> argument that describes the resulting output axis.</p><p>This all gets clearer with two small examples. suppose we want to calculate the mean of GPP, NEE and TER under the condition that Tair&lt;280K and Tair&gt;280K over all time steps and grid cells. This is achieved through the following lines of code:</p><pre><code class="language-julia">import OnlineStats
lons  = (30,31)
lats  = (50,51)
vars  = [&quot;gross_primary_productivity&quot;,&quot;net_ecosystem_exchange&quot;,&quot;terrestrial_ecosystem_respiration&quot;]
t     = getCubeData(ds,variable=&quot;air_temperature_2m&quot;,longitude=lons,latitude=lats)
cube  = getCubeData(ds,variable=vars,longitude=lons,latitude=lats)

splitTemp(t) = ifelse(t&gt;280,2,1)                            # Define the classification function
outAxis      = CategoricalAxis(&quot;TempClass&quot;,[&quot;&lt; 7C&quot;,&quot;&gt;7C&quot;])  # A two-length output axis, because there are two possible values
mT    = mapCube(OnlineStats.Mean,cube,by=[t,VariableAxis], cfun=splitTemp, outAxis=outAxis) # Of course we want to split by variable, too

using CABLABPlots
plotXY(mT,xaxis=&quot;var&quot;,group=&quot;tempclass&quot;)</code></pre><script>(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var VNode = require('vtree/vnode');
var svg = require('virtual-hyperscript/svg');
var VText = require('vtree/vtext');
var VPatch = require('vtree/vpatch');
var diff = require('virtual-dom/diff');
var patch = require('virtual-dom/patch');
var createElement = require('virtual-dom/create-element');
var nodeIndex = require('./node-index');
var patchVNode = require('./patch-vnode');
var isArray = require('x-is-array');
var isVPatch = require('./is-vpatch');

var P = Patchwork = {
    nodes: {},
    debug: false,
    Node: function (id, jlNode, el, renderOpts) {
        if (typeof(el) === "undefined") {
            el = document.getElementById(id)
        }
        this.id = id
        this.renderOptions = renderOpts
        if (jlNode) {
            // Note: makes this.root
            var vnode = P.makeVNode(jlNode)
            P.log("makeVNode: ", jlNode, "=>", vnode)
            this.mount(vnode, el, renderOpts)
        }
        P.nodes[id] = this
    },
    NAMESPACES: {
        "xhtml": null,
        "svg": "http://www.w3.org/2000/svg",
        null: null,
        undefined: null
    },
    refDiff: function (a, b, p) {
        var a = P.makeVNode(a)
            b = P.makeVNode(b)
            p = P.makeVPatches(a, p)
        console.log(p, diff(a, b));
    },
    massageProps: function (props) {
        if ("attributes" in props) {
            // we can't send undefined over JSON, so we turn nulls into undefs
            // so that VDom calls removeAttribute on the DOM node.
            //console.log("attributes ", props.attributes)
            for (var attr in props.attributes) {
                if (!props.attributes.hasOwnProperty(attr)) {
                    continue
                }
                if (props.attributes[attr] === null) {
                //console.log("remove ", attr, props.attributes[attr]);
                    props.attributes[attr] = undefined
                }
            }
        }
        return P.setupHooks(props);
    },
    hooks: {},
    register_hook: function (hook, f) {
        P.hooks[hook] = f;
    },
    setupHooks: function (props) {
        if (typeof props !== "object" || props == null) {
            return props;
        } else if (props && "_hook" in props) {
            if (props._hook in P.hooks) {
                v = P.hooks[props._hook](P.setupHooks(props.val));
                return v
            } else {
                console.warn("Unknown hook " + props._hook + "use Patchwork.register_hook to set it up")
                return undefined
            }
        } else {
            for (var k in props) {
                props[k] = P.setupHooks(props[k]);
            }
            return props;
        }
    },
    makeVNode: function (jlNode) {
        if ('txt' in jlNode) return new VText(jlNode.txt);
        var children = [],
            props = P.massageProps(jlNode.p || {})

        if (jlNode.c) {
            for (var i = 0, l = jlNode.c.length; i < l; i++) {
                children[i] = P.makeVNode(jlNode.c[i])
            }
        }

        if (jlNode.n === "svg") {
            return svg(jlNode.t, props, children)
        } else {
            var key = null
            if (props && props.key) {
                key = props.key
                delete props.key
            }
            return new VNode(jlNode.t,
                             props,
                             children,
                             key,
                             P.NAMESPACES[jlNode.n]);
        }
    },
    makeVPatches: function (root, jlPatches) {
        var indices = [];
        var vpatches = {a: root}
        for (var idx in jlPatches) {
            if (!jlPatches.hasOwnProperty(idx)) {
                continue
            }
            indices.push(Number(idx))
        }
        nodes = nodeIndex(root, indices)

        for (var idx in jlPatches) {
            vpatches[idx] = P.makeVPatch(nodes[idx], jlPatches[idx]);
        }
        return vpatches
    },
    makeVPatch: function (vnode, jlPatch) {
        if (isArray(jlPatch)) {
            // multiple patches to the same VNode
            var ps = [];
            for (var i=0, l=jlPatch.length; i < l; i++) {
                ps[i] = P.makeVPatch(vnode, jlPatch[i])
            }
            return ps
        }

        var type, patch;
        for (var k in jlPatch) {
            type = k;
            patch = jlPatch[k];
            break; // inorite?
        }

        function vpatch(p) { return new VPatch(type, vnode, p); }

        switch (Number(type)) {
        case VPatch.VTEXT:
            return vpatch(new VText(patch));
        case VPatch.VNODE:
            return vpatch(P.makeVNode(patch));
        case VPatch.PROPS:
            patch = P.massageProps(patch)
            if (vnode.namespace === P.NAMESPACES["svg"]) {
                patch = svg('dummy', patch, []).properties
            }
            return vpatch(patch);
        case VPatch.ORDER:
            return vpatch(patch);
        case VPatch.INSERT:
            return vpatch(P.makeVNode(patch));
        case VPatch.REMOVE:
            return vpatch(null);
        default:
            return null;
        }
    },
    log: function () {
        if (console && P.debug) {
            console.log.apply(console, arguments);
        }
    }
}

Patchwork.Node.prototype = {
    mount: function (vnode, outer, renderOpts) {
        var el = createElement(vnode, renderOpts);
        P.log("createElement: ", vnode, "=>", el)
        outer.appendChild(el)
        this.element = el
        this.root = vnode;
        return el;
    },
    applyPatch: function (vpatches) {
        // apply patch to DOM nodes
        if (!isVPatch(vpatches)) {
            vpatches = P.makeVPatches(this.root, vpatches)
        }
        this.element = patch(this.element, vpatches, this.renderOptions)
        this.root = patchVNode(this.root, vpatches)
    }
}

function init(nb, cue) {
    if (!Patchwork.inited) {
        try {
            console.log("attempting Patchwork setup, cue:", cue)
            var commMgr =  nb.kernel.comm_manager;
            commMgr.register_target("PatchStream", function (comm, msg) {
                var nodeId = msg.content.data.pwid;
                comm.on_msg(function (msg) {
                    var node = P.nodes[nodeId],
                        patches = msg.content.data
                    node.applyPatch(patches)
                    P.log("received patches", patches)
                });
            });
            Patchwork.inited = true;
        } catch (e) {
            Patchwork.inited = false;
            console.log("ERROR initializing patchwork: ", e);
            console.log("attempting failed, cue:", cue)
        }
    }
}

// IJulia setup
if (typeof(window.IPython) !== "undefined") {
    init(IPython.notebook, "immediate");
    $(document).ready(function () { init(IPython.notebook, "document ready"); });
    $([IPython.events]).on("kernel_ready.Kernel kernel_created.Kernel", function (evt, nb) {
        init(nb, "kernel start")
    })
}

window.Patchwork = Patchwork;

},{"./is-vpatch":2,"./node-index":3,"./patch-vnode":58,"virtual-dom/create-element":5,"virtual-dom/diff":6,"virtual-dom/patch":23,"virtual-hyperscript/svg":47,"vtree/vnode":53,"vtree/vpatch":54,"vtree/vtext":55,"x-is-array":56}],2:[function(require,module,exports){
var version = require("vtree/version")

module.exports = isVirtualPatch

function isVirtualPatch(x) {
    return x && x.type === "VirtualPatch" && x.version === version
}

},{"vtree/version":52}],3:[function(require,module,exports){
module.exports = nodeIndex

function nodeIndex(tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(tree, indices, nodes, 0)
    }
}

function recurse(tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (tree) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = tree
        }

        var vChildren = tree.children

        if (vChildren) {

            for (var i = 0; i < vChildren.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i]
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    } else {
        rootIndex
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],4:[function(require,module,exports){
module.exports = isObject

function isObject(x) {
    return typeof x === "object" && x !== null
}

},{}],5:[function(require,module,exports){
var createElement = require("vdom/create-element")

module.exports = createElement

},{"vdom/create-element":8}],6:[function(require,module,exports){
var diff = require("vtree/diff")

module.exports = diff

},{"vtree/diff":14}],7:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("vtree/is-vhook")

module.exports = applyProperties

function applyProperties(node, props, previous, renderOptions) {
    var domNode = renderOptions && renderOptions.extractNode ?
            renderOptions.extractNode(node) : node

    for (var propName in props) {
        var propValue = props[propName]

        if (propValue === undefined) {
            removeProperty(domNode, props, previous, propName);
        } else if (isHook(propValue)) {
            propValue.hook(domNode,
                propName,
                previous ? previous[propName] : undefined)
        } else {
            if (isObject(propValue)) {
                patchObject(domNode, props, previous, propName, propValue);
            } else if (propValue !== undefined) {
                domNode[propName] = propValue
            }
        }
    }
}

function removeProperty(node, props, previous, propName) {
    if (previous) {
        var previousValue = previous[propName]

        if (!isHook(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName)
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = ""
                }
            } else if (typeof previousValue === "string") {
                node[propName] = ""
            } else {
                node[propName] = null
            }
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName]

            if (attrValue === undefined) {
                node.removeAttribute(attrName)
            } else {
                node.setAttribute(attrName, attrValue)
            }
        }

        return
    }

    if(previousValue && isObject(previousValue) &&
        getPrototype(previousValue) !== getPrototype(propValue)) {
        node[propName] = propValue
        return
    }

    if (!isObject(node[propName])) {
        node[propName] = {}
    }

    var replacer = propName === "style" ? "" : undefined

    for (var k in propValue) {
        var value = propValue[k]
        node[propName][k] = (value === undefined) ? replacer : value
    }
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

},{"is-object":4,"vtree/is-vhook":17}],8:[function(require,module,exports){
var document = require("global/document")

var applyProperties = require("./apply-properties")

var isVNode = require("vtree/is-vnode")
var isVText = require("vtree/is-vtext")
var isWidget = require("vtree/is-widget")
var handleThunk = require("vtree/handle-thunk")

module.exports = createElement

function id(x) { return x }

function createElement(vnode, opts) {

    var doc = opts ? opts.document || document : document
    var warn = opts ? opts.warn : null

    vnode = handleThunk(vnode).a

    if (isWidget(vnode)) {
        return vnode.init()
    } else if (isVText(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode)
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName, vnode.properties.is) :
        doc.createElementNS(vnode.namespace, vnode.tagName)

    var props = vnode.properties
    applyProperties(node, props, null, opts)

    var children = vnode.children

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts)
        if (childNode) {
            node.appendChild(childNode)
        }
    }

    return node
}

},{"./apply-properties":7,"global/document":10,"vtree/handle-thunk":15,"vtree/is-vnode":18,"vtree/is-vtext":19,"vtree/is-widget":20}],9:[function(require,module,exports){
// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {}

module.exports = domIndex

function domIndex(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode
        }

        var vChildren = tree.children

        if (vChildren) {

            var childNodes = rootNode.childNodes

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i] || noChild
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],10:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"min-document":60}],11:[function(require,module,exports){
var applyProperties = require("./apply-properties")

var isWidget = require("vtree/is-widget")
var VPatch = require("vtree/vpatch")

var render = require("./create-element")
var updateWidget = require("./update-widget")

module.exports = applyPatch

function applyPatch(vpatch, domNode, renderOptions) {
    var type = vpatch.type
    var vNode = vpatch.vNode
    var patch = vpatch.patch

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch.ORDER:
            reorderChildren(domNode, patch)
            return domNode
        case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties, renderOptions)
            return domNode
        case VPatch.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode

    if (parentNode) {
        parentNode.removeChild(domNode)
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = render(vNode, renderOptions)

    if (parentNode) {
        parentNode.appendChild(newNode)
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text)
        newNode = domNode
    } else {
        var parentNode = domNode.parentNode
        newNode = render(vText, renderOptions)

        if (parentNode) {
            parentNode.replaceChild(newNode, domNode)
        }
    }

    destroyWidget(domNode, leftVNode)

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    if (updateWidget(leftVNode, widget)) {
        return widget.update(leftVNode, domNode) || domNode
    }

    var parentNode = domNode.parentNode
    var newWidget = render(widget, renderOptions)

    if (parentNode) {
        parentNode.replaceChild(newWidget, domNode)
    }

    destroyWidget(domNode, leftVNode)

    return newWidget
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode
    var newNode = render(vNode, renderOptions)

    if (parentNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    destroyWidget(domNode, leftVNode)

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget(w)) {
        w.destroy(domNode)
    }
}

function reorderChildren(domNode, bIndex) {
    var children = []
    var childNodes = domNode.childNodes
    var len = childNodes.length
    var i
    var reverseIndex = bIndex.reverse

    for (i = 0; i < len; i++) {
        children.push(domNode.childNodes[i])
    }

    var insertOffset = 0
    var move
    var node
    var insertNode
    for (i = 0; i < len; i++) {
        move = bIndex[i]
        if (move !== undefined && move !== i) {
            // the element currently at this index will be moved later so increase the insert offset
            if (reverseIndex[i] > i) {
                insertOffset++
            }

            node = children[move]
            insertNode = childNodes[i + insertOffset] || null
            if (node !== insertNode) {
                domNode.insertBefore(node, insertNode)
            }

            // the moved element came from the front of the array so reduce the insert offset
            if (move < i) {
                insertOffset--
            }
        }

        // element at this index is scheduled to be removed so increase insert offset
        if (i in bIndex.removes) {
            insertOffset++
        }
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        console.log(oldRoot)
        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
    }

    return newRoot;
}

},{"./apply-properties":7,"./create-element":8,"./update-widget":13,"vtree/is-widget":20,"vtree/vpatch":22}],12:[function(require,module,exports){
var document = require("global/document")
var isArray = require("x-is-array")

var domIndex = require("./dom-index")
var patchOp = require("./patch-op")
module.exports = patch

function patch(rootNode, patches, renderOptions) {
    return patchRecursive(rootNode, patches, renderOptions)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches)

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices)
    var ownerDocument = rootNode.ownerDocument

    if (!renderOptions) {
        renderOptions = {}
        if (ownerDocument !== document) {
            renderOptions.document = ownerDocument
        }
    }

    if (!renderOptions.patch) {
        renderOptions.patch = patchRecursive
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i]
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions)
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode

    if (isArray(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions)

            if (domNode === rootNode) {
                rootNode = newNode
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions)

        if (domNode === rootNode) {
            rootNode = newNode
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = []

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key))
        }
    }

    return indices
}

},{"./dom-index":9,"./patch-op":11,"global/document":10,"x-is-array":56}],13:[function(require,module,exports){
var isWidget = require("vtree/is-widget")

module.exports = updateWidget

function updateWidget(a, b) {
    if (isWidget(a) && isWidget(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

},{"vtree/is-widget":20}],14:[function(require,module,exports){
var isArray = require("x-is-array")
var isObject = require("is-object")

var VPatch = require("./vpatch")
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")
var handleThunk = require("./handle-thunk")

module.exports = diff

function diff(a, b) {
    var patch = { a: a }
    walk(a, b, patch, 0)
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        if (isThunk(a) || isThunk(b)) {
            thunks(a, b, patch, index)
        } else {
            hooks(b, patch, index)
        }
        return
    }

    var apply = patch[index]

    if (b == null) {
        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
        destroyWidgets(a, patch, index)
    } else if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index)
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties, b.hooks)
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch))
                }
                apply = diffChildren(a, b, patch, apply, index)
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
                destroyWidgets(a, patch, index)
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
            destroyWidgets(a, patch, index)
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
            destroyWidgets(a, patch, index)
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
        }
    } else if (isWidget(b)) {
        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))

        if (!isWidget(a)) {
            destroyWidgets(a, patch, index)
        }
    }

    if (apply) {
        patch[index] = apply
    }
}

function diffProps(a, b, hooks) {
    var diff

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {}
            diff[aKey] = undefined
        }

        var aValue = a[aKey]
        var bValue = b[aKey]

        if (hooks && aKey in hooks) {
            diff = diff || {}
            diff[aKey] = bValue
        } else {
            if (isObject(aValue) && isObject(bValue)) {
                if (getPrototype(bValue) !== getPrototype(aValue)) {
                    diff = diff || {}
                    diff[aKey] = bValue
                } else {
                    var objectDiff = diffProps(aValue, bValue)
                    if (objectDiff) {
                        diff = diff || {}
                        diff[aKey] = objectDiff
                    }
                }
            } else if (aValue !== bValue) {
                diff = diff || {}
                diff[aKey] = bValue
            }
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {}
            diff[bKey] = b[bKey]
        }
    }

    return diff
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children
    var bChildren = reorder(aChildren, b.children)

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i]
        var rightNode = bChildren[i]
        index += 1

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode))
            }
        } else if (!rightNode) {
            if (leftNode) {
                // Excess nodes in a need to be removed
                patch[index] = new VPatch(VPatch.REMOVE, leftNode, null)
                destroyWidgets(leftNode, patch, index)
            }
        } else {
            walk(leftNode, rightNode, patch, index)
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count
        }
    }

    if (bChildren.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(VPatch.ORDER, a, bChildren.moves))
    }

    return apply
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = new VPatch(VPatch.REMOVE, vNode, null)
        }
    } else if (isVNode(vNode) && vNode.hasWidgets) {
        var children = vNode.children
        var len = children.length
        for (var i = 0; i < len; i++) {
            var child = children[i]
            index += 1

            destroyWidgets(child, patch, index)

            if (isVNode(child) && child.count) {
                index += child.count
            }
        }
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b);
    var thunkPatch = diff(nodes.a, nodes.b)
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true;
        }
    }

    return false;
}

// Execute hooks when two nodes are identical
function hooks(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = new VPatch(VPatch.PROPS, vNode.hooks, vNode.hooks)
        }

        if (vNode.descendantHooks) {
            var children = vNode.children
            var len = children.length
            for (var i = 0; i < len; i++) {
                var child = children[i]
                index += 1

                hooks(child, patch, index)

                if (isVNode(child) && child.count) {
                    index += child.count
                }
            }
        }
    }
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {

    var bKeys = keyIndex(bChildren)

    if (!bKeys) {
        return bChildren
    }

    var aKeys = keyIndex(aChildren)

    if (!aKeys) {
        return bChildren
    }

    var bMatch = {}, aMatch = {}

    for (var key in bKeys) {
        bMatch[bKeys[key]] = aKeys[key]
    }

    for (var key in aKeys) {
        aMatch[aKeys[key]] = bKeys[key]
    }

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen
    var shuffle = []
    var freeIndex = 0
    var i = 0
    var moveIndex = 0
    var moves = {}
    var removes = moves.removes = {}
    var reverse = moves.reverse = {}
    var hasMoves = false

    while (freeIndex < len) {
        var move = aMatch[i]
        if (move !== undefined) {
            shuffle[i] = bChildren[move]
            if (move !== moveIndex) {
                moves[move] = moveIndex
                reverse[moveIndex] = move
                hasMoves = true
            }
            moveIndex++
        } else if (i in aMatch) {
            shuffle[i] = undefined
            removes[i] = moveIndex++
            hasMoves = true
        } else {
            while (bMatch[freeIndex] !== undefined) {
                freeIndex++
            }

            if (freeIndex < len) {
                var freeChild = bChildren[freeIndex]
                if (freeChild) {
                    shuffle[i] = freeChild
                    if (freeIndex !== moveIndex) {
                        hasMoves = true
                        moves[freeIndex] = moveIndex
                        reverse[moveIndex] = freeIndex
                    }
                    moveIndex++
                }
                freeIndex++
            }
        }
        i++
    }

    if (hasMoves) {
        shuffle.moves = moves
    }

    return shuffle
}

function keyIndex(children) {
    var i, keys

    for (i = 0; i < children.length; i++) {
        var child = children[i]

        if (child.key !== undefined) {
            keys = keys || {}
            keys[child.key] = i
        }
    }

    return keys
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray(apply)) {
            apply.push(patch)
        } else {
            apply = [apply, patch]
        }

        return apply
    } else {
        return patch
    }
}

},{"./handle-thunk":15,"./is-thunk":16,"./is-vnode":18,"./is-vtext":19,"./is-widget":20,"./vpatch":22,"is-object":4,"x-is-array":56}],15:[function(require,module,exports){
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")

module.exports = handleThunk

function handleThunk(a, b) {
    var renderedA = a
    var renderedB = b

    if (isThunk(b)) {
        renderedB = renderThunk(b, a)
    }

    if (isThunk(a)) {
        renderedA = renderThunk(a, null)
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous)
    }

    if (!(isVNode(renderedThunk) ||
            isVText(renderedThunk) ||
            isWidget(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

},{"./is-thunk":16,"./is-vnode":18,"./is-vtext":19,"./is-widget":20}],16:[function(require,module,exports){
module.exports = isThunk

function isThunk(t) {
    return t && t.type === "Thunk"
}

},{}],17:[function(require,module,exports){
module.exports = isHook

function isHook(hook) {
    return hook && typeof hook.hook === "function" &&
        !hook.hasOwnProperty("hook")
}

},{}],18:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualNode

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version
}

},{"./version":21}],19:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualText

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version
}

},{"./version":21}],20:[function(require,module,exports){
module.exports = isWidget

function isWidget(w) {
    return w && w.type === "Widget"
}

},{}],21:[function(require,module,exports){
module.exports = "1"

},{}],22:[function(require,module,exports){
var version = require("./version")

VirtualPatch.NONE = 0
VirtualPatch.VTEXT = 1
VirtualPatch.VNODE = 2
VirtualPatch.WIDGET = 3
VirtualPatch.PROPS = 4
VirtualPatch.ORDER = 5
VirtualPatch.INSERT = 6
VirtualPatch.REMOVE = 7
VirtualPatch.THUNK = 8

module.exports = VirtualPatch

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type)
    this.vNode = vNode
    this.patch = patch
}

VirtualPatch.prototype.version = version
VirtualPatch.prototype.type = "VirtualPatch"

},{"./version":21}],23:[function(require,module,exports){
var patch = require("vdom/patch")

module.exports = patch

},{"vdom/patch":12}],24:[function(require,module,exports){
module.exports = AttributeHook;

function AttributeHook(value) {
    if (!(this instanceof AttributeHook)) {
        return new AttributeHook(value);
    }

    this.value = value;
}

AttributeHook.prototype.hook = function (node, prop, prev) {
    if (prev && prev.value === this.value) {
        return;
    }

    node.setAttributeNS(null, prop, this.value)
}

},{}],25:[function(require,module,exports){
var DataSet = require("data-set")

module.exports = DataSetHook;

function DataSetHook(value) {
    if (!(this instanceof DataSetHook)) {
        return new DataSetHook(value);
    }

    this.value = value;
}

DataSetHook.prototype.hook = function (node, propertyName) {
    var ds = DataSet(node)
    var propName = propertyName.substr(5)

    ds[propName] = this.value;
};

},{"data-set":30}],26:[function(require,module,exports){
var DataSet = require("data-set")

module.exports = DataSetHook;

function DataSetHook(value) {
    if (!(this instanceof DataSetHook)) {
        return new DataSetHook(value);
    }

    this.value = value;
}

DataSetHook.prototype.hook = function (node, propertyName) {
    var ds = DataSet(node)
    var propName = propertyName.substr(3)

    ds[propName] = this.value;
};

},{"data-set":30}],27:[function(require,module,exports){
module.exports = SoftSetHook;

function SoftSetHook(value) {
    if (!(this instanceof SoftSetHook)) {
        return new SoftSetHook(value);
    }

    this.value = value;
}

SoftSetHook.prototype.hook = function (node, propertyName) {
    if (node[propertyName] !== this.value) {
        node[propertyName] = this.value;
    }
};

},{}],28:[function(require,module,exports){
var VNode = require("vtree/vnode.js")
var VText = require("vtree/vtext.js")
var isVNode = require("vtree/is-vnode")
var isVText = require("vtree/is-vtext")
var isWidget = require("vtree/is-widget")
var isHook = require("vtree/is-vhook")
var isVThunk = require("vtree/is-thunk")
var TypedError = require("error/typed")

var parseTag = require("./parse-tag.js")
var softSetHook = require("./hooks/soft-set-hook.js")
var dataSetHook = require("./hooks/data-set-hook.js")
var evHook = require("./hooks/ev-hook.js")

var UnexpectedVirtualElement = TypedError({
    type: "virtual-hyperscript.unexpected.virtual-element",
    message: "Unexpected virtual child passed to h().\n" +
        "Expected a VNode / Vthunk / VWidget / string but:\n" +
        "got a {foreignObjectStr}.\n" +
        "The parent vnode is {parentVnodeStr}.\n" +
        "Suggested fix: change your `h(..., [ ... ])` callsite.",
    foreignObjectStr: null,
    parentVnodeStr: null,
    foreignObject: null,
    parentVnode: null
})

module.exports = h

function h(tagName, properties, children) {
    var childNodes = []
    var tag, props, key, namespace

    if (!children && isChildren(properties)) {
        children = properties
        props = {}
    }

    props = props || properties || {}
    tag = parseTag(tagName, props)

    // support keys
    if ("key" in props) {
        key = props.key
        props.key = undefined
    }

    // support namespace
    if ("namespace" in props) {
        namespace = props.namespace
        props.namespace = undefined
    }

    // fix cursor bug
    if (tag === "input" &&
        "value" in props &&
        props.value !== undefined &&
        !isHook(props.value)
    ) {
        props.value = softSetHook(props.value)
    }

    var keys = Object.keys(props)
    var propName, value
    for (var j = 0; j < keys.length; j++) {
        propName = keys[j]
        value = props[propName]
        if (isHook(value)) {
            continue
        }

        // add data-foo support
        if (propName.substr(0, 5) === "data-") {
            props[propName] = dataSetHook(value)
        }

        // add ev-foo support
        if (propName.substr(0, 3) === "ev-") {
            props[propName] = evHook(value)
        }
    }

    if (children !== undefined && children !== null) {
        addChild(children, childNodes, tag, props)
    }


    var node = new VNode(tag, props, childNodes, key, namespace)

    return node
}

function addChild(c, childNodes, tag, props) {
    if (typeof c === "string") {
        childNodes.push(new VText(c))
    } else if (isChild(c)) {
        childNodes.push(c)
    } else if (Array.isArray(c)) {
        for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props)
        }
    } else if (c === null || c === undefined) {
        return
    } else {
        throw UnexpectedVirtualElement({
            foreignObjectStr: JSON.stringify(c),
            foreignObject: c,
            parentVnodeStr: JSON.stringify({
                tagName: tag,
                properties: props
            }),
            parentVnode: {
                tagName: tag,
                properties: props
            }
        })
    }
}

function isChild(x) {
    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x)
}

function isChildren(x) {
    return typeof x === "string" || Array.isArray(x) || isChild(x)
}

},{"./hooks/data-set-hook.js":25,"./hooks/ev-hook.js":26,"./hooks/soft-set-hook.js":27,"./parse-tag.js":46,"error/typed":37,"vtree/is-thunk":38,"vtree/is-vhook":39,"vtree/is-vnode":40,"vtree/is-vtext":41,"vtree/is-widget":42,"vtree/vnode.js":44,"vtree/vtext.js":45}],29:[function(require,module,exports){
module.exports = createHash

function createHash(elem) {
    var attributes = elem.attributes
    var hash = {}

    if (attributes === null || attributes === undefined) {
        return hash
    }

    for (var i = 0; i < attributes.length; i++) {
        var attr = attributes[i]

        if (attr.name.substr(0,5) !== "data-") {
            continue
        }

        hash[attr.name.substr(5)] = attr.value
    }

    return hash
}

},{}],30:[function(require,module,exports){
var createStore = require("weakmap-shim/create-store")
var Individual = require("individual")

var createHash = require("./create-hash.js")

var hashStore = Individual("__DATA_SET_WEAKMAP@3", createStore())

module.exports = DataSet

function DataSet(elem) {
    var store = hashStore(elem)

    if (!store.hash) {
        store.hash = createHash(elem)
    }

    return store.hash
}

},{"./create-hash.js":29,"individual":31,"weakmap-shim/create-store":32}],31:[function(require,module,exports){
(function (global){
var root = typeof window !== 'undefined' ?
    window : typeof global !== 'undefined' ?
    global : {};

module.exports = Individual

function Individual(key, value) {
    if (root[key]) {
        return root[key]
    }

    Object.defineProperty(root, key, {
        value: value
        , configurable: true
    })

    return value
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],32:[function(require,module,exports){
var hiddenStore = require('./hidden-store.js');

module.exports = createStore;

function createStore() {
    var key = {};

    return function (obj) {
        if (typeof obj !== 'object' || obj === null) {
            throw new Error('Weakmap-shim: Key must be object')
        }

        var store = obj.valueOf(key);
        return store && store.identity === key ?
            store : hiddenStore(obj, key);
    };
}

},{"./hidden-store.js":33}],33:[function(require,module,exports){
module.exports = hiddenStore;

function hiddenStore(obj, key) {
    var store = { identity: key };
    var valueOf = obj.valueOf;

    Object.defineProperty(obj, "valueOf", {
        value: function (value) {
            return value !== key ?
                valueOf.apply(this, arguments) : store;
        },
        writable: true
    });

    return store;
}

},{}],34:[function(require,module,exports){
module.exports = function(obj) {
    if (typeof obj === 'string') return camelCase(obj);
    return walk(obj);
};

function walk (obj) {
    if (!obj || typeof obj !== 'object') return obj;
    if (isDate(obj) || isRegex(obj)) return obj;
    if (isArray(obj)) return map(obj, walk);
    return reduce(objectKeys(obj), function (acc, key) {
        var camel = camelCase(key);
        acc[camel] = walk(obj[key]);
        return acc;
    }, {});
}

function camelCase(str) {
    return str.replace(/[_.-](\w|$)/g, function (_,x) {
        return x.toUpperCase();
    });
}

var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
};

var isDate = function (obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
};

var isRegex = function (obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var has = Object.prototype.hasOwnProperty;
var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

function map (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
    }
    return res;
}

function reduce (xs, f, acc) {
    if (xs.reduce) return xs.reduce(f, acc);
    for (var i = 0; i < xs.length; i++) {
        acc = f(acc, xs[i], i);
    }
    return acc;
}

},{}],35:[function(require,module,exports){
var nargs = /\{([0-9a-zA-Z]+)\}/g
var slice = Array.prototype.slice

module.exports = template

function template(string) {
    var args

    if (arguments.length === 2 && typeof arguments[1] === "object") {
        args = arguments[1]
    } else {
        args = slice.call(arguments, 1)
    }

    if (!args || !args.hasOwnProperty) {
        args = {}
    }

    return string.replace(nargs, function replaceArg(match, i, index) {
        var result

        if (string[index - 1] === "{" &&
            string[index + match.length] === "}") {
            return i
        } else {
            result = args.hasOwnProperty(i) ? args[i] : null
            if (result === null || result === undefined) {
                return ""
            }

            return result
        }
    })
}

},{}],36:[function(require,module,exports){
module.exports = extend

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],37:[function(require,module,exports){
var camelize = require("camelize")
var template = require("string-template")
var extend = require("xtend/mutable")

module.exports = TypedError

function TypedError(args) {
    if (!args) {
        throw new Error("args is required");
    }
    if (!args.type) {
        throw new Error("args.type is required");
    }
    if (!args.message) {
        throw new Error("args.message is required");
    }

    var message = args.message

    if (args.type && !args.name) {
        var errorName = camelize(args.type) + "Error"
        args.name = errorName[0].toUpperCase() + errorName.substr(1)
    }

    createError.type = args.type;
    createError._name = args.name;

    return createError;

    function createError(opts) {
        var result = new Error()

        Object.defineProperty(result, "type", {
            value: result.type,
            enumerable: true,
            writable: true,
            configurable: true
        })

        var options = extend({}, args, opts)

        extend(result, options)
        result.message = template(message, options)

        return result
    }
}


},{"camelize":34,"string-template":35,"xtend/mutable":36}],38:[function(require,module,exports){
module.exports=require(16)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-thunk.js":16}],39:[function(require,module,exports){
module.exports=require(17)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vhook.js":17}],40:[function(require,module,exports){
module.exports=require(18)
},{"./version":43,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vnode.js":18}],41:[function(require,module,exports){
module.exports=require(19)
},{"./version":43,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vtext.js":19}],42:[function(require,module,exports){
module.exports=require(20)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-widget.js":20}],43:[function(require,module,exports){
module.exports=require(21)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/version.js":21}],44:[function(require,module,exports){
var version = require("./version")
var isVNode = require("./is-vnode")
var isWidget = require("./is-widget")
var isVHook = require("./is-vhook")

module.exports = VirtualNode

var noProperties = {}
var noChildren = []

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName
    this.properties = properties || noProperties
    this.children = children || noChildren
    this.key = key != null ? String(key) : undefined
    this.namespace = (typeof namespace === "string") ? namespace : null

    var count = (children && children.length) || 0
    var descendants = 0
    var hasWidgets = false
    var descendantHooks = false
    var hooks

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName]
            if (isVHook(property)) {
                if (!hooks) {
                    hooks = {}
                }

                hooks[propName] = property
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i]
        if (isVNode(child)) {
            descendants += child.count || 0

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true
            }
        } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true
            }
        }
    }

    this.count = count + descendants
    this.hasWidgets = hasWidgets
    this.hooks = hooks
    this.descendantHooks = descendantHooks
}

VirtualNode.prototype.version = version
VirtualNode.prototype.type = "VirtualNode"

},{"./is-vhook":39,"./is-vnode":40,"./is-widget":42,"./version":43}],45:[function(require,module,exports){
var version = require("./version")

module.exports = VirtualText

function VirtualText(text) {
    this.text = String(text)
}

VirtualText.prototype.version = version
VirtualText.prototype.type = "VirtualText"

},{"./version":43}],46:[function(require,module,exports){
var classIdSplit = /([\.#]?[a-zA-Z0-9_:-]+)/
var notClassId = /^\.|#/

module.exports = parseTag

function parseTag(tag, props) {
    if (!tag) {
        return "div"
    }

    var noId = !("id" in props)

    var tagParts = tag.split(classIdSplit)
    var tagName = null

    if (notClassId.test(tagParts[1])) {
        tagName = "div"
    }

    var classes, part, type, i
    for (i = 0; i < tagParts.length; i++) {
        part = tagParts[i]

        if (!part) {
            continue
        }

        type = part.charAt(0)

        if (!tagName) {
            tagName = part
        } else if (type === ".") {
            classes = classes || []
            classes.push(part.substring(1, part.length))
        } else if (type === "#" && noId) {
            props.id = part.substring(1, part.length)
        }
    }

    if (classes) {
        if (props.className) {
            classes.push(props.className)
        }

        props.className = classes.join(" ")
    }

    return tagName ? tagName.toLowerCase() : "div"
}

},{}],47:[function(require,module,exports){
var attributeHook = require("./hooks/attribute-hook.js")
var h = require("./index.js")

var BLACKLISTED_KEYS = {
    "style": true,
    "namespace": true,
    "key": true
}
var SVG_NAMESPACE = "http://www.w3.org/2000/svg"

module.exports = svg

function svg(tagName, properties, children) {
    if (!children && isChildren(properties)) {
        children = properties
        properties = {}
    }

    properties = properties || {}

    // set namespace for svg
    properties.namespace = SVG_NAMESPACE

    // for each key, if attribute & string, bool or number then
    // convert it into a setAttribute hook
    for (var key in properties) {
        if (!properties.hasOwnProperty(key)) {
            continue
        }

        if (BLACKLISTED_KEYS[key]) {
            continue
        }

        var value = properties[key]
        if (typeof value !== "string" &&
            typeof value !== "number" &&
            typeof value !== "boolean"
        ) {
            continue
        }

        properties[key] = attributeHook(value)
    }

    return h(tagName, properties, children)
}

function isChildren(x) {
    return typeof x === "string" || Array.isArray(x)
}

},{"./hooks/attribute-hook.js":24,"./index.js":28}],48:[function(require,module,exports){
module.exports=require(17)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vhook.js":17}],49:[function(require,module,exports){
module.exports=require(18)
},{"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vnode.js":18}],50:[function(require,module,exports){
module.exports=require(19)
},{"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vtext.js":19}],51:[function(require,module,exports){
module.exports=require(20)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-widget.js":20}],52:[function(require,module,exports){
module.exports=require(21)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/version.js":21}],53:[function(require,module,exports){
module.exports=require(44)
},{"./is-vhook":48,"./is-vnode":49,"./is-widget":51,"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-hyperscript/node_modules/vtree/vnode.js":44}],54:[function(require,module,exports){
module.exports=require(22)
},{"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/vpatch.js":22}],55:[function(require,module,exports){
module.exports=require(45)
},{"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-hyperscript/node_modules/vtree/vtext.js":45}],56:[function(require,module,exports){
var nativeIsArray = Array.isArray
var toString = Object.prototype.toString

module.exports = nativeIsArray || isArray

function isArray(obj) {
    return toString.call(obj) === "[object Array]"
}

},{}],57:[function(require,module,exports){
isObject = require('is-object')

module.exports = {reorder: reorder,
                  patchObject: patchObject}

function reorder(array, moves) {
    if (!arr) { return }
    var copy = array.slice(0)

    for (var i=0, l=array.length; i < l; i++) {
        var move = moves[i]
        if (move !== undefined) {
            array[move] = copy[i]
        }
    }
    return array
}

function patchObject(obj, patch) {
    for (var key in patch) {
        if (patch[key] && typeof patch[key].hook == "function") {
            obj[key] = patch[key]
        } else if (isObject(patch[key]) && isObject(obj[key])) {
            obj[key] = patchObject(obj[key], patch[key]);
        } else {
            obj[key] = patch[key]
        }
    }
}


},{"is-object":4}],58:[function(require,module,exports){
var mutateNode = require("./vnode-patch-op")
var isArray = require('x-is-array')

module.exports = patchVNode

function patchVNode(root, patches) {

    linkParents(root)

    for (var key in patches) {
        if (key === "a") continue
        patch = patches[key]
        if (isArray(patch)) {

            for (var i=0, l=patch.length; i < l; i++) {
                mutateNode(patch[i].type, patch[i].vNode, patch[i].patch)
            }
        } else {
            mutateNode(patch.type, patch.vNode, patch.patch)
        }
    }

    return root
}

function linkParents(vNode) {
    if (!vNode || !vNode.children) { return }

    var children = vNode.children
    for (var i=0, l=children.length; i < l; i++) {
        children[i].up = vNode
        linkParents(children[i])
    }
}

},{"./vnode-patch-op":59,"x-is-array":56}],59:[function(require,module,exports){
var isWidget = require("vtree/is-widget")
var isVText = require("vtree/is-vtext")
var VPatch = require("vtree/vpatch")
var patchUtil = require("./patch-util.js")

module.exports = applyPatch

function applyPatch(type, vNode, patch) {

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(vNode)
        case VPatch.INSERT:
            return insertNode(vNode, patch)
        case VPatch.VTEXT:
            return stringPatch(vNode, patch)
        case VPatch.VNODE:
            return vNodePatch(vNode, patch)
        case VPatch.ORDER:
            patchUtil.reorder(vNode.children, patch)
            return vNode
        case VPatch.PROPS:
            patchUtil.patchObject(vNode.properties, patch)
            return vNode
        default:
            return vNode
    }
}

function offsetCount(node, count) {
    if (!node) { return }
    if (node.count !== undefined) {
        node.count = node.count + count
        offsetCount(node.up, count)
    } else {
        node.count = count
    }
}

function removeNode(node) {
    if (!node) { return }
    var count = node.count,
        up = node.up

    var idx = up.children.indexOf(node)
    if (idx > -1) {
        up.children.splice(idx, 1)
        var count = 0
        if (isVText(node)) {
            count = -1
        } else {
            count = -node.count - 1
        }
        offsetCount(up, count)
    }
    delete node

    return null
}

function insertNode(node, child) {
    node.children.push(child)
    var count = 0
    if (isVText(child)) {
        count = 1
    } else {
        count = child.count + 1
    }
    offsetCount(node, count)
    child.up = node
    return node
}

function stringPatch(node, patch) {
    node.text = patch.text
    return node
}

function vNodePatch(node, patch) {
    var up = node.up
    if (!up) {
        // copy over the patch to the root node
        for (key in patch) {
            if (!patch.hasOwnProperty(key)) continue
            node[key] = patch[key]
        }
        return
    }
    var idx = up.children.indexOf(node),
        count = patch.count || 0

    if (idx > -1) {
        up.children[idx] = patch
        if (node.count != count) {
            offsetCount(up, count - node.count)
        }
    }

    return node
}

},{"./patch-util.js":57,"vtree/is-vtext":50,"vtree/is-widget":51,"vtree/vpatch":54}],60:[function(require,module,exports){

},{}]},{},[1]);
</script><?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="600" height="400" viewBox="0 0 600 400">
<defs>
  <clipPath id="clip00">
    <rect x="0" y="0" width="600" height="400"/>
  </clipPath>
</defs>
<polygon clip-path="url(#clip00)" points="
0,400 600,400 600,0 0,0 
  " fill="#ffffff" fill-opacity="1"/>
<defs>
  <clipPath id="clip01">
    <rect x="120" y="0" width="421" height="400"/>
  </clipPath>
</defs>
<polygon clip-path="url(#clip00)" points="
12.8259,369.674 596.063,369.674 596.063,3.93701 12.8259,3.93701 
  " fill="#ffffff" fill-opacity="1"/>
<defs>
  <clipPath id="clip02">
    <rect x="12" y="3" width="584" height="366"/>
  </clipPath>
</defs>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:0.5; fill:none" stroke-dasharray="1, 2" points="
  106.334,364.188 106.334,9.42306 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:0.5; fill:none" stroke-dasharray="1, 2" points="
  304.444,364.188 304.444,9.42306 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:0.5; fill:none" stroke-dasharray="1, 2" points="
  502.555,364.188 502.555,9.42306 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:0.5; fill:none" stroke-dasharray="1, 2" points="
  21.5745,306.182 587.314,306.182 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:0.5; fill:none" stroke-dasharray="1, 2" points="
  21.5745,223.613 587.314,223.613 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:0.5; fill:none" stroke-dasharray="1, 2" points="
  21.5745,141.044 587.314,141.044 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:0.5; fill:none" stroke-dasharray="1, 2" points="
  21.5745,58.475 587.314,58.475 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  12.8259,369.674 596.063,369.674 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  106.334,369.674 106.334,364.188 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  304.444,369.674 304.444,364.188 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  502.555,369.674 502.555,364.188 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  12.8259,369.674 12.8259,3.93701 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  12.8259,306.182 21.5745,306.182 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  12.8259,223.613 21.5745,223.613 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  12.8259,141.044 21.5745,141.044 
  "/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  12.8259,58.475 21.5745,58.475 
  "/>
<g clip-path="url(#clip00)">
<text style="fill:#00002d; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:end;" transform="rotate(0, 11.6259, 310.682)" x="11.6259" y="310.682">0</text>
</g>
<g clip-path="url(#clip00)">
<text style="fill:#00002d; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:end;" transform="rotate(0, 11.6259, 228.113)" x="11.6259" y="228.113">1</text>
</g>
<g clip-path="url(#clip00)">
<text style="fill:#00002d; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:end;" transform="rotate(0, 11.6259, 145.544)" x="11.6259" y="145.544">2</text>
</g>
<g clip-path="url(#clip00)">
<text style="fill:#00002d; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:end;" transform="rotate(0, 11.6259, 62.975)" x="11.6259" y="62.975">3</text>
</g>
<g clip-path="url(#clip00)">
<text style="fill:#00002d; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:16; text-anchor:middle;" transform="rotate(0, 304.444, 397.6)" x="304.444" y="397.6">Variable</text>
</g>
<polygon clip-path="url(#clip02)" points="
27.0898,265.935 27.0898,306.182 106.334,306.182 106.334,265.935 27.0898,265.935 27.0898,265.935 
  " fill="#0099ff" fill-opacity="1"/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  27.0898,265.935 27.0898,306.182 106.334,306.182 106.334,265.935 27.0898,265.935 
  "/>
<polygon clip-path="url(#clip02)" points="
225.2,285.498 225.2,306.182 304.444,306.182 304.444,285.498 225.2,285.498 225.2,285.498 
  " fill="#0099ff" fill-opacity="1"/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  225.2,285.498 225.2,306.182 304.444,306.182 304.444,285.498 225.2,285.498 
  "/>
<polygon clip-path="url(#clip02)" points="
423.311,242.425 423.311,306.182 502.555,306.182 502.555,242.425 423.311,242.425 423.311,242.425 
  " fill="#0099ff" fill-opacity="1"/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  423.311,242.425 423.311,306.182 502.555,306.182 502.555,242.425 423.311,242.425 
  "/>
<polygon clip-path="url(#clip02)" points="
106.334,3.93701 106.334,306.182 185.578,306.182 185.578,3.93701 106.334,3.93701 106.334,3.93701 
  " fill="#e9746a" fill-opacity="1"/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  106.334,3.93701 106.334,306.182 185.578,306.182 185.578,3.93701 106.334,3.93701 
  "/>
<polygon clip-path="url(#clip02)" points="
304.444,369.674 304.444,306.182 383.689,306.182 383.689,369.674 304.444,369.674 304.444,369.674 
  " fill="#e9746a" fill-opacity="1"/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  304.444,369.674 304.444,306.182 383.689,306.182 383.689,369.674 304.444,369.674 
  "/>
<polygon clip-path="url(#clip02)" points="
502.555,68.4524 502.555,306.182 581.799,306.182 581.799,68.4524 502.555,68.4524 502.555,68.4524 
  " fill="#e9746a" fill-opacity="1"/>
<polyline clip-path="url(#clip02)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  502.555,68.4524 502.555,306.182 581.799,306.182 581.799,68.4524 502.555,68.4524 
  "/>
<polygon clip-path="url(#clip00)" points="
492.7,70.177 578.063,70.177 578.063,24.817 492.7,24.817 
  " fill="#ffffff" fill-opacity="1"/>
<polyline clip-path="url(#clip00)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  492.7,70.177 578.063,70.177 578.063,24.817 492.7,24.817 492.7,70.177 
  "/>
<polygon clip-path="url(#clip00)" points="
498.7,45.985 534.7,45.985 534.7,33.889 498.7,33.889 498.7,45.985 
  " fill="#0099ff" fill-opacity="1"/>
<polyline clip-path="url(#clip00)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  498.7,45.985 534.7,45.985 534.7,33.889 498.7,33.889 498.7,45.985 
  "/>
<g clip-path="url(#clip00)">
<text style="fill:#00002d; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:start;" transform="rotate(0, 540.7, 44.437)" x="540.7" y="44.437">&lt; 7C</text>
</g>
<polygon clip-path="url(#clip00)" points="
498.7,61.105 534.7,61.105 534.7,49.009 498.7,49.009 498.7,61.105 
  " fill="#e9746a" fill-opacity="1"/>
<polyline clip-path="url(#clip00)" style="stroke:#00002d; stroke-width:0.8; stroke-opacity:1; fill:none" points="
  498.7,61.105 534.7,61.105 534.7,49.009 498.7,49.009 498.7,61.105 
  "/>
<g clip-path="url(#clip00)">
<text style="fill:#00002d; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:start;" transform="rotate(0, 540.7, 59.557)" x="540.7" y="59.557">&gt;7C</text>
</g>
</svg>
<p>A second example would be that we want to calculate averages of the fluxes according to a country mask.</p><pre><code class="language-julia">import OnlineStats
vars  = [&quot;gross_primary_productivity&quot;,&quot;net_ecosystem_exchange&quot;,&quot;terrestrial_ecosystem_respiration&quot;]
m     = getCubeData(ds,variable=&quot;country_mask&quot;,longitude=lons,latitude=lats)
cube  = getCubeData(ds,variable=vars,longitude=lons,latitude=lats)

mT    = mapCube(OnlineStats.Mean,cube,by=[m,VariableAxis], cfun=splitTemp, outAxis=outAxis)</code></pre><p>This will split the cube by country and variable and compute averages over the input variables.</p><h3><a class="nav-anchor" id="Online-PCA-1" href="#Online-PCA-1">Online PCA</a></h3><p>It is possible to compute a principal component analysis based on a covariance matrix obtained through an online algorithm. The package provides a convenient way to achieve this with the cubePCA function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CABLAB.Proc.DATOnlineStats.cubePCA" href="#CABLAB.Proc.DATOnlineStats.cubePCA"><code>CABLAB.Proc.DATOnlineStats.cubePCA</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cubePCA(cube::AbstractCubeData)</code></pre><p>Performs a PCA based on a covariance matrix which is estimated through an online algorithm. Returns an OnlinePCA object from which <a href="@ref">explained_variance</a> and the <a href="@ref">rotation</a> can be extracted, or which can be used to perform the projection on a dataset.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>MDAxis</code> specifies the axes that is reduced through the PCA</p></li><li><p><code>by</code> a vector of axes types or masks denoting if several PCAs should be performed. If provided, several PCAs will be performed.</p></li><li><p><code>noutdims</code> number of output dimensions, how many PCs are estimated</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/CAB-LAB/CABLAB.jl/tree/e9dddd56e7c0249f98316f0e4927aff0722deea1/src/Proc/OnlinePCA.jl#L94-L107">source</a><br/></section><p>For example, if one wants to calculate a PCA over the time dimension, you could use the following code:</p><footer><hr/><a class="previous" href="cube_access.html"><span class="direction">Previous</span><span class="title">Accessing the Data Cube</span></a><a class="next" href="plotting.html"><span class="direction">Next</span><span class="title">Plotting</span></a></footer></article></body></html>
