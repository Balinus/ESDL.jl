<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis · ESDL.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="ESDL.jl logo"/></a><h1>ESDL.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../cube_access/">Accessing the Data Cube</a></li><li class="current"><a class="toctext" href>Analysis</a><ul class="internal"><li><a class="toctext" href="#Built-in-Functions-1">Built-in Functions</a></li><li><a class="toctext" href="#Simple-Statistics-1">Simple Statistics</a></li><li><a class="toctext" href="#(Weighted-)OnlineStats-1">(Weighted-)OnlineStats</a></li><li><a class="toctext" href="#Elementwise-calculations-1">Elementwise calculations</a></li><li><a class="toctext" href="#Applying-custom-functions-1">Applying custom functions</a></li></ul></li><li><a class="toctext" href="../plotting/">Plotting</a></li><li><a class="toctext" href="../iotools/">Loading and saving results</a></li></ul></li><li><a class="toctext" href="../lib/misc/">Other functions</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Analysis</a></li></ul><a class="edit-page" href="https://github.com/esa-esdl/ESDL.jl/blob/master/docs/src/analysis.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Analysis</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Analysis-1" href="#Analysis-1">Analysis</a></h1><p>The ESDL package comes with a list of predefined methods for statistical analysis. The functions are defined to work on specific axes. For example a function that removes the mean annual cycle, will always extract one time series after the other from a cube, process them, store the results and concatenate the resulting time series to a new output cube. It does not matter which other axes are defined in the input cube, the function will simply loop over these.</p><p>The function will be applied to the whole cube in a memory-efficient way, which means that chunks of data are read, processed and then saved in the output cube. Whether the output cube is a <a href="../cube_access/#ESDL.Cubes.MmapCube"><code>MmapCube</code></a> or a <a href="../cube_access/#ESDL.Cubes.CubeMem"><code>CubeMem</code></a> is decided by the system, depending on parallelization and the size of the output cube.</p><p>Here follows a list of analysis functions included in this package. If you have implemented or wrapped a method, that might be of interest to a broader community, please feel free to open a pull request.</p><h2><a class="nav-anchor" id="Built-in-Functions-1" href="#Built-in-Functions-1">Built-in Functions</a></h2><h3><a class="nav-anchor" id="Seasonal-cycles-1" href="#Seasonal-cycles-1">Seasonal cycles</a></h3><p>All of these functions take a data cube as an argument, process the <strong>input axis</strong> and replace it with the <strong>output axis</strong>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.MSC.gapFillMSC-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.MSC.gapFillMSC-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.MSC.gapFillMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">gapFillMSC(c::AbstractCubeData)</code></pre><p>Fills missing values of each time series in a cube with the mean annual cycle.</p><p><strong>Input Axis</strong> <code>Time</code>axis</p><p><strong>Output Axis</strong> <code>Time</code>axis</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/Proc/MSC.jl#L39-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.MSC.getMSC-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.MSC.getMSC-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.MSC.getMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getMSC(c::AbstractCubeData)</code></pre><p>Returns the mean annual cycle from each time series.</p><p><strong>Input Axis</strong> <code>Time</code>axis</p><p><strong>Output Axis</strong> <code>MSC</code>axis</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/Proc/MSC.jl#L59-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.MSC.getMedSC-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.MSC.getMedSC-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.MSC.getMedSC</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">getMedMSC(c::AbstractCubeData)</code></pre><p>Returns the median annual cycle from each time series.</p><p><strong>Input Axis</strong> <code>Time</code>axis</p><p><strong>Output Axis</strong> <code>MSC</code>axis</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/Proc/MSC.jl#L106-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.MSC.removeMSC-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.MSC.removeMSC-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.MSC.removeMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">removeMSC(c::AbstractCubeData)</code></pre><p>Removes the mean annual cycle from each time series of a data cube.</p><p><strong>Input Axis</strong> <code>Time</code>axis</p><p><strong>Output Axis</strong> <code>Time</code>axis</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/Proc/MSC.jl#L16-L24">source</a></section><h3><a class="nav-anchor" id="Time-series-decomposition-1" href="#Time-series-decomposition-1">Time series decomposition</a></h3><p>This function takes a data cube as an argument. It adds an additional dimension to the cube and returns it. Every variable, time step and location will have a set of four values in the new dimension instead of just one.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.TSDecomposition.filterTSFFT-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.TSDecomposition.filterTSFFT-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.TSDecomposition.filterTSFFT</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">filterTSFFT(c::AbstractCubeData)</code></pre><p>Filter each time series using a Fourier filter and return the decomposed series in 4 time windows (Trend, Long-Term Variability, Annual Cycle, Fast Oscillations)</p><p><strong>Input Axis</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis, <code>Scale</code>axis</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/Proc/TSDecomposition.jl#L32-L42">source</a></section><h3><a class="nav-anchor" id="Cube-transformations-1" href="#Cube-transformations-1">Cube transformations</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.CubeIO.exportcube-Tuple{ESDL.Cubes.AbstractCubeData,String}" href="#ESDL.Proc.CubeIO.exportcube-Tuple{ESDL.Cubes.AbstractCubeData,String}"><code>ESDL.Proc.CubeIO.exportcube</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">exportcube(r::AbstractCubeData,filename::String)</code></pre><p>Saves a cube object to a portable NetCDF file in <code>filename</code>.</p><p>When saving, every RangeAxis will be converted to an axis in the NetCDF cube, while every categorical axis will be represented by a different variable inside the resulting file. Dimensions will be ordered according to the <code>priorities</code> keyword argument, which defaults to <code>Dict(&quot;LON&quot;=&gt;1,&quot;LAT&quot;=&gt;2,&quot;TIME&quot;=&gt;3)</code>, which means that the file will be stored with longitudes varying fastest.</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/Proc/CubeIO.jl#L111-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.CubeIO.extractLonLats-Tuple{ESDL.Cubes.AbstractCubeData,Array{T,2} where T}" href="#ESDL.Proc.CubeIO.extractLonLats-Tuple{ESDL.Cubes.AbstractCubeData,Array{T,2} where T}"><code>ESDL.Proc.CubeIO.extractLonLats</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">extractLonLats(c::AbstractCubeData,pl::Matrix)</code></pre><p>Extracts a list of longitude/latitude coordinates from a data cube. The coordinates are specified through the matrix <code>pl</code> where <code>size(pl)==(N,2)</code> and N is the number of extracted coordinates. Returns a data cube without <code>LonAxis</code> and <code>LatAxis</code> but with a <code>SpatialPointAxis</code> containing the input locations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/Proc/CubeIO.jl#L28-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.CubeIO.sampleLandPoints" href="#ESDL.Proc.CubeIO.sampleLandPoints"><code>ESDL.Proc.CubeIO.sampleLandPoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sampleLandPoints(cube, nsample;nomissing=false)</code></pre><p>Get an area-weighted sample from all non-ocean grid cells. This will return a new Cube where the <code>LonAxis</code> and <code>LatAxis</code> are condensed into a single <code>SpatialPointAxis</code> of length <code>nsample</code>. If <code>nomissing=true</code> only grid cells will be selected which don&#39;t contain any missing values. This makes sense for gap-filled cubes to make sure that grid cells with systematic seasonal gaps are not selected in the sample.</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/Proc/CubeIO.jl#L54-L62">source</a></section><h2><a class="nav-anchor" id="Simple-Statistics-1" href="#Simple-Statistics-1">Simple Statistics</a></h2><p>Another typical use case is the application of basic statistics like <code>sum</code>, <code>mean</code> and <code>std</code> applied on one or more cube axes. We therefore overload the method <code>mapslices</code> for data cubes.</p><p>The main difference to the function exported in Base is that the dimensions to be sliced over are given by name and not by dimension index. For example,</p><pre><code class="language-julia">mapslices(mean, cube, (&quot;Lon&quot;,&quot;Lat&quot;))</code></pre><p>will compute the mean over each spatial map contained in the data cube. Please note that that the <code>mapslices</code> function will execute the function once with random number input to determine the shape of the returned values and then pre-allocate the output array. Keep this in mind when your function has some side-effects. Although the <code>mapslices</code> function should <em>work</em> in most cases, it is advised to read about the <a href="#ESDL.DAT.mapCube"><code>mapCube</code></a> function in <a href="#Applying-custom-functions-1">Applying custom functions</a> which gives you much more detailed control over the mapping operation.</p><p>Applying these basic statistics functions makes sense, if the slices one wants to reduce fit in memory. However, if one wants to calculate some statistics on e.g. a <em>time x lon x lat</em> cube, one would preferably call one of the <a href="#(Weighted-)OnlineStats-1">(Weighted-)OnlineStats</a> methods.  </p><p>An additional simple statistic function is:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.Stats.normalizeTS-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.Stats.normalizeTS-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.Stats.normalizeTS</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">normalizeTS(c::AbstractCubeData)</code></pre><p>Normalize a time series to zero mean and unit variance</p><p><strong>Input Axes</strong> <code>TimeAxis</code></p><p><strong>Output Axes</strong> <code>TimeAxis</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/Proc/Stats.jl#L12-L20">source</a></section><h2><a class="nav-anchor" id="(Weighted-)OnlineStats-1" href="#(Weighted-)OnlineStats-1">(Weighted-)OnlineStats</a></h2><p>It is possible to directly apply statistics included in the <a href="https://github.com/joshday/OnlineStats.jl">OnlineStats.jl package</a>, as well as the <a href="https://github.com/gdkrmr/WeightedOnlineStats.jl">WeightedOnlineStats.jl package</a> on the data cube. Thus, statistical operations on data too big to fit into memory can be handled. The way to do this, is to first create a table interface to the cube, using the <a href="#ESDL.DAT.@CubeTable"><code>@CubeTable</code></a> macro and then applying the required type of statistic using the <a href="#ESDL.DAT.cubefittable"><code>cubefittable</code></a> function:</p><pre><code class="language-julia">cTable = @CubeTable value=cube axes=(lat, lon, time, variable) fastest=variable
outCube = cubefittable(cTable, o, :value; by=by, weight=weightfun)</code></pre><p>where <code>o</code> is a (Weighted-)OnlineStat data type and <code>cube</code> is the cube you want to apply the statistics to. The parameter name <code>value</code> in the <a href="#ESDL.DAT.@CubeTable"><code>@CubeTable</code></a> macro and the corresponding symobl <code>:value</code> in the example above can be chosen arbitrarily, as long as they are equal in the macro and the <a href="#ESDL.DAT.cubefittable"><code>cubefittable</code></a> function. By default the <a href="#ESDL.DAT.cubefittable"><code>cubefittable</code></a> function will reduce all values over all axes of the cube, so if you want to do statistics grouped by variables on a certain axis, it has to be specified using the <code>by</code> keyword argument. <code>by</code> accepts a tuple of symbols and/or functions. If the cube supplied to the macro has more than one variable, it makes sense to at least supply <code>by=(:variable,)</code> to the function or else values of different variables will be mixed during calculation. The use of <a href="https://github.com/gdkrmr/WeightedOnlineStats.jl">WeightedOnlineStats</a> is encouraged to compensate for the increasing number of grid cells per area unit in higher latitudes.</p><p>The following two examples illustrate the use of these functions. Suppose we want to calculate the mean of GPP, NEE and TER under the condition that Tair&lt;280K and Tair&gt;280K over all time steps and grid cells. This is achieved through the following lines of code:</p><pre><code class="language-">using ESDL, WeightedOnlineStats
lons  = (30,31)
lats  = (50,51)
vars  = [&quot;gross_primary_productivity&quot;,&quot;net_ecosystem_exchange&quot;,&quot;terrestrial_ecosystem_respiration&quot;]
c = Cube()
cube  = getCubeData(c,variable=vars,longitude=lons,latitude=lats)
t     = getCubeData(c,variable=&quot;air_temperature_2m&quot;,longitude=lons,latitude=lats)

splitTemp(t) = if !ismissing(t) if t&gt;280 return &quot;T&gt;7C&quot; else return &quot;T&lt;7C&quot; end else return missing end # Define the classification function
cTable = @CubeTable value=cube axes=(lat,lon,time,variable) temp=t
cubefittable(cTable, WeightedMean, :value, by=(i-&gt;splitTemp(i.temp), :variable), weight=(i-&gt;cosd(i.lat)))</code></pre><pre><code class="language-none">In-Memory data cube with the following dimensions
Category1           Axis with 2 elements: T&lt;7C T&gt;7C
Variable            Axis with 3 elements: gross_primary_productivity net_ecosystem_exchange terrestrial_ecosystem_respiration
Total size: 54.0 bytes</code></pre><p>A second example would be that we want to calculate averages of the fluxes according to a country mask.</p><pre><code class="language-">using ESDL, WeightedOnlineStats
vars  = [&quot;gross_primary_productivity&quot;,&quot;net_ecosystem_exchange&quot;,&quot;terrestrial_ecosystem_respiration&quot;]
c     = Cube()
m     = getCubeData(c,variable=&quot;country_mask&quot;,longitude=lons,latitude=lats)
cube  = getCubeData(c,variable=vars,longitude=lons,latitude=lats)

cTable = @CubeTable value=cube axes=(lat,lon,time,variable) country=m
cubefittable(cTable, WeightedMean, :value, by=(:country, :variable), weight=(i-&gt;cosd(i.lat)))</code></pre><pre><code class="language-none">In-Memory data cube with the following dimensions
Country             Axis with 1 elements: Ukraine
Variable            Axis with 3 elements: gross_primary_productivity net_ecosystem_exchange terrestrial_ecosystem_respiration
Total size: 27.0 bytes</code></pre><p>This will split the cube by country and variable and compute averages over the input variables.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.DAT.@CubeTable" href="#ESDL.DAT.@CubeTable"><code>ESDL.DAT.@CubeTable</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@CubeTable input_vars...</code></pre><p>Macro to turn a DataCube object into an iterable table. Takes a list of as arguments, specified either by a cube variable name alone or by a <code>name=cube</code> expression. For example <code>@CubeTable cube1 country=cube2</code> would generate a Table with the entries <code>cube1</code> and <code>country</code>, where <code>cube1</code> contains the values of <code>cube1</code> and <code>country</code> the values of <code>cube2</code>. The cubes are matched and broadcasted along their axes like in <code>mapCube</code>.</p><p>In addition, one can specify <code>axes=(ax1,ax2...)</code> when one wants to include the values of certain xes in the table. For example the command <code>@CubeTable tair=cube1 axes=(lon,lat,time)</code> would produce an iterator over a data structure with entries <code>tair</code>, <code>lon</code>, <code>lat</code> and <code>time</code>.</p><p>Lastly there is an option to specify which axis shall be the fastest changing when iterating over the cube. For example <code>@CubeTable cube1 fastest=time</code> will ensure that the iterator will always loop over consecutive time steps of the same location.</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/DAT/dciterators.jl#L215-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.DAT.fittable" href="#ESDL.DAT.fittable"><code>ESDL.DAT.fittable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fittable(tab,o,fitsym;by=(),weight=nothing)</code></pre><p>Loops through an iterable table <code>tab</code> and thereby fitting an OnlineStat <code>o</code> with the values specified through <code>fitsym</code>. Optionally one can specify a field (or tuple) to group by. Any groupby specifier can either be a symbol denoting the entry to group by or an anynymous function calculating the group from a table row.</p><p>For example the following would caluclate a weighted mean over a cube weighted by grid cell area and grouped by country and month:</p><pre><code class="language-julia">fittable(iter,WeightedMean,:tair,weight=(i-&gt;abs(cosd(i.lat))),by=(i-&gt;month(i.time),:country))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/DAT/tablestats.jl#L207-L221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.DAT.cubefittable" href="#ESDL.DAT.cubefittable"><code>ESDL.DAT.cubefittable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cubefittable(tab,o,fitsym;post=getpostfunction(o),kwargs...)</code></pre><p>Executes <a href="#ESDL.DAT.fittable"><code>fittable</code></a> on the <a href="#ESDL.DAT.@CubeTable"><code>@CubeTable</code></a> <code>tab</code> with the (Weighted-)OnlineStat <code>o</code>, looping through the values specified by <code>fitsym</code>. Finally, writes the results from the <code>TableAggregator</code> to an output data cube.</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/DAT/tablestats.jl#L259-L265">source</a></section><h3><a class="nav-anchor" id="Online-Histograms-and-quantiles-1" href="#Online-Histograms-and-quantiles-1">Online Histograms and quantiles</a></h3><p>It is possible to estimate histograms and quantiles of larger-than-memory datasets using an adaptive-bin histogram algorithm. The <code>Base.quantile</code> method is overloaded for objects of type <code>AbstractCubeData</code>, so the following works to estimate the 10% and 90% quantiles of all datapoints for each variable:</p><pre><code class="language-julia">using WeightedOnlineStats
c=Cube()
d=getCubeData(c,variable=[&quot;gross_primary_productivity&quot;,&quot;net_ecosystem_exchange&quot;], region=&quot;Europe&quot;)
cTable = @CubeTable value=d axes=(lat,lon,time,variable)

fitCube=cubefittable(cTable, WeightedHist(20), :value, by=(:variable,), weight=(i-&gt;cosd(i.lat)))

q = quantile(fitCube,[0.1,0.9])</code></pre><pre><code class="language-none">In-Memory data cube with the following dimensions
Quantile            Axis with 2 Elements from 0.1 to 0.9
Variable            Axis with 2 elements: gross_primary_productivity net_ecosystem_exchange
Total size: 36.0 bytes</code></pre><pre><code class="language-julia">q.data</code></pre><pre><code class="language-none">2×2 Array{Union{Missing, Float64},2}:
 0.169621  -1.75922
 6.04165    0.641276</code></pre><p>The <code>WeightedHist</code> call in the <code>cubefittable</code> function requires an integer argument, which sets the number of adaptive bins per histogram.</p><h2><a class="nav-anchor" id="Elementwise-calculations-1" href="#Elementwise-calculations-1">Elementwise calculations</a></h2><p>Doing elementwise calculations on the cube is generally done using the <code>map</code> function. A simple example is the conversion of degree Kelvin to degree Celsius. To subtract from each element of a data cube with 273.15, you can call</p><pre><code class="language-julia">c=Cube()
kelvinCube = getCubeData(c, variable=&quot;air_temperature_2m&quot;, region=&quot;Europe&quot;)
celsiusCube = map(x -&gt; x-273.15, kelvinCube)</code></pre><pre><code class="language-none">Transformed cube Data Cube view with the following dimensions
Lon                 Axis with 172 Elements from -9.875 to 32.875
Lat                 Axis with 140 Elements from 69.875 to 35.125
Time                Axis with 1702 Elements from 1980-01-01 to 2016-12-26
Total size: 195.43 MB</code></pre><p>This will not execute the computation immediately, but on the fly during the next computation or plotting. Please note that all values in the cube will be subject to the operation. So if the cube has more than one variable, this operation will apply to the values of all variables. The following is an example for mapping multiple values:</p><pre><code class="language-julia">c=Cube()
time = (Date(&quot;2001-01-01&quot;), Date(&quot;2001-12-31&quot;))

firstCube = getCubeData(c, time=time, variable=&quot;precipitation&quot;)
secondCube = getCubeData(c, time=time, variable=&quot;interception_loss&quot;)
diffcube = map((x,y)-&gt;x-y, firstCube, secondCube)</code></pre><pre><code class="language-none">Transformed cube Data Cube view with the following dimensions
Lon                 Axis with 1440 Elements from -179.875 to 179.875
Lat                 Axis with 720 Elements from 89.875 to -89.875
Time                Axis with 46 Elements from 2001-01-01 to 2001-12-27
Total size: 227.42 MB</code></pre><p>This calculates the difference of two data cubes, in this case the difference of precipitation and interception. Note here, that in this case both cubes must have the exact same dimensions and the dimensions must consist of the same elements.</p><p>Common operations like the above examples can even be expressed in an easier way:  commonly used operators (+, -, *, /, max, min) and functions (sin, cos, exp, log, log10) are overloaded and can be applied on data cubes directly. So <code>celsiusCube = (kelvinCube - 273.15)</code> and <code>diffcube = abs(firstCube - secondCube)</code> would work as expected.</p><h2><a class="nav-anchor" id="Applying-custom-functions-1" href="#Applying-custom-functions-1">Applying custom functions</a></h2><p>The main feature of this package, and probably the one one that is most different to other geospatial frameworks is the <a href="#ESDL.DAT.mapCube"><code>mapCube</code></a> function that executes <em>arbitrary</em> functions on <em>arbitrary</em> slices (and permutations) of one or more input data cubes. The function can be written in Julia or call into C libraries, call other packages, etc. In addition, the computation will be carried out in a memory-efficient manner, such that  data is read only in chunks, processed and then re-written slice-by-slice to allow out-of-core computation. The basic working principles are:</p><ol><li>The user-defined function (UDF) <code>f</code> takes a number <code>N_in</code> of arrays as input and its output is represented in a number <code>N_out</code> of output arrays.</li><li>The function <code>f</code> has at least <code>N_out + N_in</code> arguments, where so its signature is <code>f(xout1, xout2, .... ,xoutN, xin1, xin2, ... xinN, addargs...; kwargs...)</code></li><li>Every input array of <code>f</code> will be a slice of an input data cube. The user specifies the axes that will be used for slicing by creating an <a href="#ESDL.DAT.InDims"><code>InDims</code></a> object for every input cube object and passing it to the <a href="#ESDL.DAT.mapCube"><code>mapCube</code></a> function.</li><li>The dimensions of every output array have to be specified by the user by creating an <a href="#ESDL.DAT.OutDims"><code>OutDims</code></a> object for every output cube and passing it to the <a href="#ESDL.DAT.mapCube"><code>mapCube</code></a> function.</li><li>The input data cubes may have additional dimensions which are not used for slicing, these will be iterated over and the function <code>f</code> will be called repeatedly for every slice. If there are multiple input cubes, and contain additional axes of the same name, they are required to have the same axis elements, so that these elements are matched in the loop. If different input cubes have differently named additional axes, their oputer product will be applied and the axes will all be added to the output cubes.</li></ol><h3><a class="nav-anchor" id="A-minimal-example-1" href="#A-minimal-example-1">A minimal example</a></h3><p>In order to understand how these principles are applied, let us walk through a very basic example, namely a function that normalizes the time series of a data cube. This means, we want to scale each time series in the cube in a way so its mean will be 0 and its standard deviation will be 1. To translate this into the principles mentioned above:</p><ol><li>Our function that we want to writes will take a 1D-array as an input (a time series) and write an output of the same length.</li><li>So the function will have to accept two arguments, which will be called <code>xin</code> for the input time series and <code>xout</code> for the output time series. Such a function can be defined like this:</li></ol><div><pre><code class="language-julia">using ESDL

function mynorm(xout, xin)
    # if all values in the current input slice are missing, return all missings in the output slice
    all(ismissing, xin) &amp;&amp; return xout[:]=missing
    # else calculate the mean and std of the current slice (time series of 1 variable at one location (lat/lon))
    m = mean(skipmissing(xin))
    s = std(skipmissing(xin))

    if s &gt; 0 # std non-zero
        xout[:].=(xin.-m)./s # elementwise calculation of normalized values
    else # time series is probably constant
        xout[:]=0
    end
end</code></pre><pre><code class="language-none">mynorm (generic function with 1 method)</code></pre></div><p>Next we have to define the input dimensions for our data cube. We want the function to operate on the time axis, so we create an object:</p><div><pre><code class="language-julia">indims = InDims(&quot;Time&quot;)</code></pre><pre><code class="language-none">InDims((ESDL.Cubes.Axes.ByName(&quot;Time&quot;),), AsArray(), (ESDL.DAT.AllMissing(),))</code></pre></div><p>The <a href="#ESDL.DAT.InDims"><code>InDims</code></a> constructor takes any number of positional arguments and tries to convert them into a description of a cube axis, so you can pass it a string, an axis type or an axis itself, all of which will be matched against the axes of the input data cube. Next we define the output axis:</p><div><pre><code class="language-julia">outdims = OutDims(&quot;Time&quot;)</code></pre><pre><code class="language-none">OutDims((ESDL.Cubes.Axes.ByName(&quot;Time&quot;),), (), zero, identity, :auto, false, AsArray(), 1)</code></pre></div><p>Similarly to the input cube constructor, for <a href="#ESDL.DAT.OutDims"><code>OutDims</code></a> any number of descriptors is allowed. When passed a single string or axis type, then a matching input axis will be used as the output dimension. However, when a new output axis is created by the function, other possibilities for the output axis description are possible.</p><p>Having defined these objects, we can finally load a data cube handle and apply the function, the dimension description gets passed using the <code>indims</code> and <code>outdims</code> keywords:</p><pre><code class="language-">c = Cube()
d = getCubeData(c,variable = [&quot;gross_primary_productivity&quot;, &quot;net_ecosystem_exchange&quot;],time=(DateTime(2001),DateTime(2002,12,31)), longitude = (50,51), latitude=(30,31))
d_norm = mapCube(mynorm, d, indims=indims, outdims=outdims)</code></pre><pre><code class="language-none">In-Memory data cube with the following dimensions
Time                Axis with 92 Elements from 2001-01-01 to 2002-12-27
Lon                 Axis with 4 Elements from 50.125 to 50.875
Lat                 Axis with 4 Elements from 30.875 to 30.125
Variable            Axis with 2 elements: gross_primary_productivity net_ecosystem_exchange
Total size: 14.38 KB</code></pre><p>The resulting cube has the same dimensions like the input cube. All variables except Time were just looped over and the result was stored in a new data cube.</p><h3><a class="nav-anchor" id="Calculations-on-multiple-cubes-1" href="#Calculations-on-multiple-cubes-1">Calculations on multiple cubes</a></h3><p>The first example showed how to handle a single input- and a single output- data cube. Here we give a first example for doing an operation on two output cubes having different shapes. To do this, let&#39;s go back to the <code>myNorm</code> example and assume that we do not only want to return the normalized time series but also the standard deviation and the mean of each time series. The problem is, that mean and standard deviation are scalars while the time series is a vector so they can not easily be coerced into a single output cube. The solution is to return multiple output cubes. So we define the norm function and <code>Indims</code> and <code>Outdims</code> as follows:</p><pre><code class="language-">function mynorm_return_stdm(xout_ts, xout_m, xout_s, xin)
  # Check if we have only missing values
  if all(ismissing,xin)
    xout_ts[:].=missing
    xout_m[1]=missing
    xout_s[1]=missing
  else
    m = mean(skipmissing(xin))
    s = std(skipmissing(xin))
    if s&gt;0 # See if time series is not constant
      xout_ts[:].=(xin.-m)./s
    else #Time series is probably constant
      xout_ts[:].=0.0
    end
    # Now write mean and std to output
    xout_s[1]=s
    xout_m[1]=m
  end
end

indims     = InDims(&quot;Time&quot;)
outdims_ts = OutDims(&quot;Time&quot;)
outdims_m  = OutDims()
outdims_s  = OutDims()

d_norm, m, s = mapCube(mynorm_return_stdm, d, indims=indims, outdims=(outdims_ts, outdims_m, outdims_s))</code></pre><pre><code class="language-none">(Memory mapped cube with the following dimensions
Time                Axis with 506 Elements from 2001-01-01 to 2011-12-27
Lon                 Axis with 172 Elements from -9.875 to 32.875
Lat                 Axis with 140 Elements from 69.875 to 35.125
Variable            Axis with 2 elements: gross_primary_productivity transpiration
Total size: 116.2 MB
, In-Memory data cube with the following dimensions
Lon                 Axis with 172 Elements from -9.875 to 32.875
Lat                 Axis with 140 Elements from 69.875 to 35.125
Variable            Axis with 2 elements: gross_primary_productivity transpiration
Total size: 235.16 KB
, In-Memory data cube with the following dimensions
Lon                 Axis with 172 Elements from -9.875 to 32.875
Lat                 Axis with 140 Elements from 69.875 to 35.125
Variable            Axis with 2 elements: gross_primary_productivity transpiration
Total size: 235.16 KB
)</code></pre><p>First of all lets see what changed. We added two more arguments to the UDF, which are the additional output arrays <code>xout_m</code> and <code>xout_s</code>. They contain the additional output cubes. Then we added an additional output cube description <code>OutDims()</code> for each cube, which has no argument, because these outputs are singular values (mean and standard deviation per location and variable) and don&#39;t contain any dimensions. When we apply the function, we simply pass a tuple of output cube descriptions to the <code>outdims</code> keyword and the mapCube function returns then three cubes: the full <em>(time x lon x lat x variable)</em> cube for the normalized time series and two <em>(lon x lat x variable)</em> cubes for mean and standard deviation.   </p><p>Of course, this also works the same way if you want to apply a function to multiple input data cubes. To stay with the normalization example, we assume that we want to normalize our dataset with some externally given standard deviation and mean, which are different for every pixel. Then multiple <code>InDims</code> objects have to be defined:</p><div><pre><code class="language-julia">indims_ts = InDims(&quot;Time&quot;)
indims_m  = InDims()
indims_s  = InDims()
outdims   = OutDims(&quot;Time&quot;)</code></pre><pre><code class="language-none">OutDims((ESDL.Cubes.Axes.ByName(&quot;Time&quot;),), (), zero, identity, :auto, false, AsArray(), 1)</code></pre></div><p>and define the function that does the scaling, which accepts now additional arguments for the scaling and offset:</p><pre><code class="language-">function mynorm_given_stdm(xout, xin_ts, m, s)
  xout[:]=(xin_ts[:].-m[1])./s[1]
end

mapCube(mynorm_given_stdm, (d,m,s), indims = (indims_ts, indims_m, indims_s), outdims = outdims)</code></pre><pre><code class="language-none">Memory mapped cube with the following dimensions
Time                Axis with 506 Elements from 2001-01-01 to 2011-12-27
Lon                 Axis with 172 Elements from -9.875 to 32.875
Lat                 Axis with 140 Elements from 69.875 to 35.125
Variable            Axis with 2 elements: gross_primary_productivity transpiration
Total size: 116.2 MB</code></pre><p>Note that the operation will attempt to match the axes that the cubes contain. Because the cubes <code>d</code>,<code>m</code> and <code>s</code> all contain a <code>LonAxis</code>, a <code>LatAxis</code> and a <code>VariableAxis</code> with the same values, it will loop over these, so at every pixel the corresponding mean and standard deviation values are used.</p><h3><a class="nav-anchor" id="Axes-are-cubes-1" href="#Axes-are-cubes-1">Axes are cubes</a></h3><p>In some cases one needs to have access to the value of an axis. For example when one wants to calculate a spatial aggregation, the latitudes are important to determine grid cell weights. To do this, one can pass a cube axis to mapCube as if it was a cube having only one dimension. The values will then correspond to the axis values (the latitudes in degrees in this case).</p><pre><code class="language-julia">using ESDL # hide
function spatialAggregation(xout::Array{T,0}, xin::Matrix, latitudes::AbstractVector) where T
  #code goes here
end

#Extract the latitude axis
latitudecube = ESDL.getAxis(&quot;Lat&quot;,cube)

indims_map = InDims(LonAxis, LatAxis)
indims_lat = InDims(LatAxis)
outdims    = OutDims()
mapCube(spatialAggregation, (cube,latitudecube), indims = (indims_map, indims_lat), outdims = outdims);</code></pre><p>Here, the function will operate on a <em>(lon x lat)</em> matrix and one has access to the latitude values inside the function. Note that the <a href="../lib/misc/#ESDL.Cubes.Axes.getAxis"><code>getAxis</code></a> function is very useful in this context, since it extracts the axis of a certain name from a given data cube object. Then we pass the cube axis as a second input cube to the <code>mapCube</code> function (see also <a href="#Calculations-on-multiple-cubes-1">Calculations on multiple cubes</a>).</p><h3><a class="nav-anchor" id="Passing-additional-arguments-1" href="#Passing-additional-arguments-1">Passing additional arguments</a></h3><p>If a function call needs additional arguments, they are simply appended to the <code>mapCube</code> call and then get passed to the function. For example, if one wants to apply a multivariate extreme event detection method <code>detectExtremes</code>, where one can choose from several methods, the function signature would look like this:</p><pre><code class="language-julia">function detectExtremes(xout, xin, method_name)
  #code goes here
end

inAxes  = InDims(TimeAxis,VariableAxis)
outAxes = OutDims(TimeAxis)
method = &quot;KDE&quot;
mapCube(detectExtremes, d, method, indims = inAxes, outdims = outAxes);</code></pre><p>The method would then be called e.g. with which would pass the String <code>&quot;KDE&quot;</code> as the third positional argument to the function.</p><h3><a class="nav-anchor" id="Generating-new-output-axes-1" href="#Generating-new-output-axes-1">Generating new output axes</a></h3><p>So far in our examples we always re-used axes from the input cube as output cube axes. However, it is possible to create new axes and use them for the resulting data cubes from a <code>mapCube</code> operation. The example we want to look at is a polynomial regression between two variables. Assume we want to describe the relationship between GPP and ecosystem respiration for each pixel through a polynomial of degree N.</p><p>So for each pixel we want to do the polynomial regression on the two variables and then return a vector of coefficients. We define the function that does the calculation as:</p><div><pre><code class="language-julia">using ESDL
using Polynomials
function fit_npoly(xout, var1, var2, n)
  p = polyfit(var1, var2, n)
  xout[:] = coeffs(p)
end</code></pre><pre><code class="language-none">fit_npoly (generic function with 1 method)</code></pre></div><p>Now assume we want to fit a polynomial of order 2 to our variables. We first create the output axis we want to use, you can either use <a href="../cube_access/#ESDL.Cubes.Axes.CategoricalAxis"><code>CategoricalAxis</code></a> for non-continuous quantities or <a href="../cube_access/#ESDL.Cubes.Axes.RangeAxis"><code>RangeAxis</code></a> for continuous axes. Here we create a categorical Axis and pass it to the OutDims constructor:</p><div><pre><code class="language-julia">polyaxis = CategoricalAxis(&quot;Coefficients&quot;,[&quot;Offset&quot;,&quot;1&quot;,&quot;2&quot;])

indims1  = InDims(&quot;Time&quot;)
indims2  = InDims(&quot;Time&quot;)
outdims  = OutDims(polyaxis)</code></pre><pre><code class="language-none">OutDims((ESDL.Cubes.Axes.ByValue(Coefficients        Axis with 3 elements: Offset 1 2 ),), (), zero, identity, :auto, false, AsArray(), 1)</code></pre></div><p>So here we don&#39;t describe the output axis through a type or name, but by passing an actual object. Then we can call the <code>mapCube</code> function:</p><pre><code class="language-">c   = Cube()
gpp = getCubeData(c,variable = &quot;gross_primary_productivity&quot;,time=(DateTime(2001),DateTime(2002,12,31)), longitude = (50,51), latitude=(30,31))
ter = getCubeData(c,variable = &quot;terrestrial_ecosystem_respiration&quot;,time=(DateTime(2001),DateTime(2002,12,31)), longitude = (50,51), latitude=(30,31))

mapCube(fit_npoly,(gpp,ter),2,indims = (indims1,indims2), outdims = outdims)</code></pre><pre><code class="language-none">In-Memory data cube with the following dimensions
Coefficients        Axis with 3 elements: Offset 1 2
Lon                 Axis with 4 Elements from 50.125 to 50.875
Lat                 Axis with 4 Elements from 30.875 to 30.125
Total size: 240.0 bytes</code></pre><p>Returned is a 3D cube with dimensions <em>coeff x lon x lat</em>.</p><h3><a class="nav-anchor" id="Wrapping-mapCube-calls-into-user-friendly-functions-1" href="#Wrapping-mapCube-calls-into-user-friendly-functions-1">Wrapping mapCube calls into user-friendly functions</a></h3><p>When a certain function is used more often, it makes sense to wrap it into a single function so that the user does not have to deal with the input and output dimension description. For the polynomial regression example one could, for example, define this convenience wrapper and then call it directly, now for a third-order regression:</p><pre><code class="language-">function fitpoly(cube1, cube2, n)
  polyaxis = CategoricalAxis(&quot;Coefficients&quot;,[&quot;Offset&quot;;string.(1:n)])

  indims1  = InDims(&quot;Time&quot;)
  indims2  = InDims(&quot;Time&quot;)
  outdims  = OutDims(polyaxis)

  mapCube(fit_npoly,(cube1,cube2),n,indims = (indims1,indims2), outdims = outdims)
end

fitpoly(gpp,ter,3)</code></pre><pre><code class="language-none">In-Memory data cube with the following dimensions
Coefficients        Axis with 4 elements: Offset 1 2 3
Lon                 Axis with 4 Elements from 50.125 to 50.875
Lat                 Axis with 4 Elements from 30.875 to 30.125
Total size: 320.0 bytes</code></pre><p>This is exactly the way the built-in functions in <a href="#Analysis-1">Analysis</a> were generated. So in case you want to contribute some functionality that you feel would benefit this package, please open a pull request at https://github.com/esa-esdl/ESDL.jl</p><h3><a class="nav-anchor" id="Reference-documentation-for-mapCube-related-functions-1" href="#Reference-documentation-for-mapCube-related-functions-1">Reference documentation for mapCube-related functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.DAT.InDims" href="#ESDL.DAT.InDims"><code>ESDL.DAT.InDims</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InDims(axisdesc;...)</code></pre><p>Creates a description of an Input Data Cube for cube operations. Takes a single   or a Vector/Tuple of axes as first argument. Axes can be specified by their   name (String), through an Axis type, or by passing a concrete axis.</p><p><strong>Keyword arguments</strong></p><ul><li><code>artype</code> how shall the array be represented in the inner function. Defaults to <code>AsArray</code>, alternatives are <code>AsDataFrame</code> or <code>AsAxisArray</code></li><li><code>filter</code> define some filter to skip the computation, e.g. when all values are missing. Defaults to   <code>AllMissing()</code>, possible values are <code>AnyMissing()</code>, <code>AnyOcean()</code>, <code>StdZero()</code>, <code>NValid(n)</code>   (for at least n non-missing elements). It is also possible to provide a custom one-argument function   that takes the array and returns <code>true</code> if the compuation shall be skipped and <code>false</code> otherwise.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/DAT/registration.jl#L56-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.DAT.OutDims" href="#ESDL.DAT.OutDims"><code>ESDL.DAT.OutDims</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">OutDims(axisdesc;...)</code></pre><p>Creates a description of an Output Data Cube for cube operations. Takes a single   or a Vector/Tuple of axes as first argument. Axes can be specified by their   name (String), through an Axis type, or by passing a concrete axis.</p><ul><li><code>axisdesc</code>: List of input axis names</li><li><code>genOut</code>: function to initialize the values of the output cube given its element type. Defaults to <code>zero</code></li><li><code>finalizeOut</code>: function to finalize the values of an output cube, defaults to identity.</li><li><code>retCubeType</code>: sepcifies the type of the return cube, can be <code>CubeMem</code> to force in-memory, <code>TempCube</code> to force disk storage, or <code>&quot;auto&quot;</code> to let the system decide.</li><li><code>outtype</code>: force the output type to a specific type, defaults to <code>Any</code> which means that the element type of the first input cube is used</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/DAT/registration.jl#L83-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.DAT.mapCube" href="#ESDL.DAT.mapCube"><code>ESDL.DAT.mapCube</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mapCube(fun, cube, addargs...;kwargs)</code></pre><p>Map a given function <code>fun</code> over slices of the data cube <code>cube</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>max_cache=1e7</code> maximum size of blocks that are read into memory, defaults to approx 10Mb</li><li><code>outtype::DataType</code> output data type of the operation</li><li><code>indims::InDims</code> List of input cube descriptors of type <a href="#ESDL.DAT.InDims"><code>InDims</code></a> for each input data cube</li><li><code>outdims::OutDims</code> List of output cube descriptors of type <a href="#ESDL.DAT.OutDims"><code>OutDims</code></a> for each output cube</li><li><code>inplace</code> does the function write to an output array inplace or return a single value&gt; defaults to <code>true</code></li><li><code>ispar</code> boolean to determine if parallelisation should be applied, defaults to <code>true</code> if workers are available.</li><li><code>outfolder</code> a folder where the output cube is stroed, defaults to the result of <code>ESDLdir()</code></li><li><code>showprog</code> boolean indicating if a ProgressMeter shall be shown</li><li><code>kwargs</code> additional keyword arguments passed to the inner function</li></ul><p>The first argument is always the function to be applied, the second is the input cube or a tuple input cubes if needed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/99f278666303feef16235e35534775b288c0e1f5/src/DAT/DAT.jl#L192-L211">source</a></section><footer><hr/><a class="previous" href="../cube_access/"><span class="direction">Previous</span><span class="title">Accessing the Data Cube</span></a><a class="next" href="../plotting/"><span class="direction">Next</span><span class="title">Plotting</span></a></footer></article></body></html>
