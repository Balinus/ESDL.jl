<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Applying custom functions · ESDL.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="ESDL.jl logo"/></a><h1>ESDL.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="thecube.html">The ESDL Data Cube</a></li><li><a class="toctext" href="cube_access.html">Accessing the Data Cube</a></li><li><a class="toctext" href="analysis.html">Elementwise calculations</a></li><li><a class="toctext" href="plotting.html">Plotting</a></li><li class="current"><a class="toctext" href="adding_new.html">Applying custom functions</a><ul class="internal"><li><a class="toctext" href="#Examples-1">Examples</a></li><li class="toplevel"><a class="toctext" href="#Reference-1">Reference</a></li></ul></li><li><a class="toctext" href="iotools.html">Loading and saving results</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="adding_new.html">Applying custom functions</a></li></ul><a class="edit-page" href="https://github.com/esa-esdl/ESDL.jl/blob/master/docs/src/adding_new.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Applying custom functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Applying-custom-functions-1" href="#Applying-custom-functions-1">Applying custom functions</a></h1><p>The main feature of this package, and propbably the one one that is most different to other geospatial frameworks is the <code>mapCube</code> function that lets you execute <em>arbitrary</em> functions on <em>arbitrary</em> slices (and permutations) of one or more input data cubes. The function can be pure Julia or call into C libraries, call other packages, etc. In addition, the computation will be carried out in a memory-efficient manner, which mean, that only the data is read in a chunked manner, processed and then again written slice-by-slice to allow out-of-core computation. All this is done by the <code>mapCube</code> methods which applies a user-defined function <code>f</code> on slices of the cube. The underlying principles are:</p><ol><li><p>The function <code>f</code> takes <code>N_in</code> arrays as input and its output is represented in <code>N_out</code> output arrays.</p></li><li><p>The function <code>f</code> has at least <code>N_out + N_in</code> arguments, where so its signature is <code>f(xout1, xout2, .... ,xoutN_out, xin1, xin2, ... xinN_in, addargs...; kwargs...)</code></p></li><li><p>Every input array of <code>f</code> will be a slice of an input data cube. The user specifies the axes that will be used for slicing by creating an <code>InDims</code> for every input cube object and passing it to the <code>mapCube</code> function.</p></li><li><p>The dimensions of every output array have to be specified by the user by creating an <code>OutDims</code> object for every output cube and passing it to the <code>mapCube function</code></p></li><li><p>The input data cubes may have additional dimensions which are not used for slicing, these will be iterated over and the function <code>f</code> be called repeatedly for every slice. If there are multiple input cubes, and contain additional axes of the same name, they must are required to have the same axis values, so that equal values are matched in the looped. If different input cubes have differently named additional axes, their oputer product will be applied and the axes will all be added to the output cubes.</p></li></ol><h3><a class="nav-anchor" id="A-minimal-example-1" href="#A-minimal-example-1">A minimal example</a></h3><p>In order to understand how these principles are applied, let us walk through a very basic example, namely a function that normalizes the time series of a datacube. That means, we want to scale each time series in the cube in a way that its mean is 0 and the standard deviation is 1.Let&#39;s translate this into the principles mentioned above. Our function that we want to writes will take a 1D-array as an input (a time series) and write an output of the same length. So the function will have to accept two arguments, which we will call <code>xin</code> for the inout time series and <code>xout</code> as the placeholder for the output time series. We can define such a function like this:</p><div><pre><code class="language-julia">using ESDL
function mynorm(xout, xin)
  all(ismissing,xin) &amp;&amp; return xout[:]=missing
  m = mean(skipmissing(xin))
  s = std(skipmissing(xin))
  if s&gt;0
    xout[:].=(xin.-m)./s
  else #Time series is probably constant
    xout[:]=0
  end
  nothing
end</code></pre><pre><code class="language-none">mynorm (generic function with 1 method)</code></pre></div><p>Next we have to define the input dimensions for our data cube. We want the function to operate on the time axis, so we create an object:</p><div><pre><code class="language-julia">indims = InDims(&quot;Time&quot;)</code></pre><pre><code class="language-none">ESDL.DAT.InDims((ESDL.Cubes.Axes.ByName(&quot;Time&quot;),), ESDL.DAT.DataArrayMissing(), ESDL.DAT.AsArray())</code></pre></div><p>The <a href="adding_new.html#ESDL.DAT.InDims"><code>InDims</code></a> constructor takes any number of positional arguments and tries to convert them into a description of a cube axis, so you can pass it a string, an axis type or an axis itself, all of which will be matched against the axes of the input data cube. Next we define the output axis:</p><div><pre><code class="language-julia">outdims = OutDims(&quot;Time&quot;)</code></pre><pre><code class="language-none">ESDL.DAT.OutDims((ESDL.Cubes.Axes.ByName(&quot;Time&quot;),), (), ESDL.DAT.DataArrayMissing(), zero, identity, :auto, false, ESDL.DAT.AsArray(), 1)</code></pre></div><p>Similarly to the input cube constructor, for <a href="adding_new.html#ESDL.DAT.OutDims"><code>OutDims</code></a> any number of descriptors is allowed. When passed a single string or axis type, then a matching input axis will be used as the output dimension. However, when a new output axis is created by the function, other possibilities for the output axis description are possible.</p><p>Having defined these objects, we can finally load a data cube handle and apply the function, the dimension description gets passed using the <code>indims</code> and <code>outdims</code> keywords:</p><pre><code class="language-">c = Cube()
d = getCubeData(c,variable = [&quot;gross_primary_productivity&quot;, &quot;net_ecosystem_exchange&quot;],time=(DateTime(2001),DateTime(2002,12,31)), longitude = (50,51), latitude=(30,31))
d_norm = mapCube(mynorm, d, indims=indims, outdims=outdims)</code></pre><p>The resulting cube has the same dimensions like the input cube. All variables except Time were just looped over and the result was stored in a new data cube.</p><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><h3><a class="nav-anchor" id="Using-different-representations-for-missing-data-1" href="#Using-different-representations-for-missing-data-1">Using different representations for missing data</a></h3><p>By default, the data that are passed to the user-defined function will always be represented as an Array{Union{T,Missing}}, so they use Julia&#39;s <code>Missing</code> type to represent missing data. However, there might be several reasons for the missingnes of a single data value, like it might be in the ocean, or it is out of the dataset period or it is an observation gap. In the ESDC this information is stored in a special mask type (see <a href="cube_access.html#Cube-Masks-1">Cube Masks</a>), that can be accessed inside the UDF. For example, if we want to rewrite the <code>myNorm</code> function defined above, but we want to only calculate the mean and std based on values that were not gapfilled, one could do so:</p><pre><code class="language-julia">import ESDL.Mask
function mynorm(xout, ain)
  #Destructure the tuple into the data and mask array
  xin,min = ain
  #Get the valid data points that are not filled
  validx = find(i-&gt;Mask.isvalid(i) &amp;&amp; !Mask.isfilled(i),min)
  # Check if we have valid points at all
  isempty(validx) &amp;&amp; return xout[:]=missing
  #Filter data
  xin = xin[validx]
  m = mean(xin)
  s = std(xin)
  if s&gt;0
    xout[:].=(xin.-m)./s
  else #Time series is probably constant
    xout[:]=0
  end
  nothing
end


indims  = InDims(&quot;time&quot;,miss = ESDL.MaskMissing())
outdims = OutDims(&quot;time&quot;)

mapCube(mynorm, d, indims = indims, outdims = outdims, no_ocean=1)</code></pre><p>Let&#39;s see what we changed. First when constructing the <code>InDims</code> object we used the <code>miss</code> keyword argument to specify that we want missing values represented by an extra mask. This tells the <code>mapCube</code> function to pass the first input cube as a tuple instead of as a DataArray. Inside the function, we first destructure the tuple into the mask and the data, determine the missing and filled values from the mask and then do the computation on the filtered data. See <a href="adding_new.html#ESDL.DAT.InDims"><code>InDims</code></a> for more options on representation of missing data.</p><h3><a class="nav-anchor" id="Passing-additional-arguments-1" href="#Passing-additional-arguments-1">Passing additional arguments</a></h3><p>If a function call needs additional arguments, they are simple appended to the <code>mapCube</code> call and then get passed to the function. For example, if one wants to apply a multivariate extreme event detection method <code>detectExtremes</code>, where one can choose from several methods, the function signature would look like this:</p><pre><code class="language-julia">function detectExtremes(xout::Vector, xin::Matrix, method)
  #code goes here
end

inAxes  = InDims(TimeAxis,VariableAxis,miss = NaNMissing())
outAxes = OutDims(TimeAxis,miss=NaNMissing())
methods = &quot;KDE&quot;
mapCube(detectExtremes, cube, &quot;KDE&quot;, indims = inAxes, outdims = outAxes, no_ocean=1);</code></pre><p>The method would then be called e.g. with which would pass the String <code>&quot;KDE&quot;</code> as the third positional argument to the function.</p><h3><a class="nav-anchor" id="Calculations-on-multiple-cubes-1" href="#Calculations-on-multiple-cubes-1">Calculations on multiple cubes</a></h3><p>So far we showed only examples with a single input data cube. Here we give a first example for doing operations on two input cubes having different shapes. Let&#39;s say we have a model that predicts the biospheric CO2 uptake over a given time range based on the data cube <code>cubedata</code>, which has the axes lon x lat x time x variable. This model depends on the vegetation type of each grid cell, which is a static variable and stored in a second data cube <code>staticdata</code> with the axes lon x lat. We call the function like this:</p><pre><code class="language-julia">using ESDL # hide
function predictCarbonSink{T,U}(xout::Array{T,0}, xin::Matrix, vegmask::Array{U,0})
  #Code goes here
end
inAxes=(InDims(TimeAxis, VariableAxis),InDims())
outAxes=OutDims()
mapCube(predictCarbonSink, (cube, vegmask), indims = inAxes, outdims = outAxes, no_ocean=2);</code></pre><p>The input cubes <code>inAxes</code> is now a tuple <code>InDims</code>, one for each input cube. From <code>cubedata</code> we want to extract the whole time series of all variables, while from <code>staticdata</code> we only need one value for the current pixel. When calling this function, make sure to put the input cubes into a tuple (<code>mapCube(predictCarbonSink,(cubedata, staticdata))</code>). Note that we set the optional argument <code>no_ocean=2</code> This means that, again, ocean grid cells are skipped, but the <code>2</code> denotes that this time the second input cube will be checked for ocean cells, not the first one.</p><h3><a class="nav-anchor" id="Axes-are-cubes-1" href="#Axes-are-cubes-1">Axes are cubes</a></h3><p>In some cases one needs to have access to the value of an axis, for example when one wants to calculate a spatial Aggregation, the latitudes are important to determine grid cell weights. To do this, one can pass a cube axis to mapCube as if it was a cube having only one dimension.</p><pre><code class="language-julia">using ESDL # hide
function spatialAggregation{T}(xout::Array{T,0}, xin::Matrix, latitudes::AbstractVector)
  #code goes here
end

indims=(InDims(LonAxis, LatAxis,miss=DataArrayMissing()), InDims(LatAxis,miss=ESDL.NoMissing()))
outdims=OutDims()
mapCube(spatialAggregation, (cube,ESDL.getAxis(&quot;Lat&quot;,cube)), indims = indims, outdims = outdims);</code></pre><p>Here, the function will operate on a lon x lat matrix and one has access to the latitude values inside the function. For the second input cube the input axis we extract the latitude axis from the first user-supplied cube and pass it to the calculation as a second input cube. So we apply the function using:</p><h3><a class="nav-anchor" id="Determine-output-axis-from-cube-properties-1" href="#Determine-output-axis-from-cube-properties-1">Determine output axis from cube properties</a></h3><p>For some calculations the output axis does not equal any of the input axis, but has to be generated before the cube calculation starts. You can probably guess that this will happen through callback functions again, which have the same form as in the other examples. In this example we want to call a function that does a polynomial regression between time series of two variables. The result of this calculation are the regression parameters, so the output axis will be a newly created <code>Parameter</code>-axis (see <a href="@ref">Cube Axes</a>). For the axis we define a default constructor which names the fitting parameters. In this example we create a ParameterAxis for a quadratic regression.</p><div><pre><code class="language-julia">function ParameterAxis(order::Integer)
  order &gt; 0 || error(&quot;Regression must be at least linear&quot;)
  CategoricalAxis(&quot;Parameter&quot;,[&quot;offset&quot;;[&quot;p$i&quot; for i=1:order]])
end
ParameterAxis(2)</code></pre><pre><code class="language-none">Parameter           Axis with elements: offset p1 p2</code></pre></div><p>Now we can go and call the function, while we specify the output axis with a function calling the Axis constructor.</p><pre><code class="language-julia">using ESDL # hide
function ParameterAxis(order::Integer) # hide
  order &gt; 0 || error(&quot;Regression must be at least linear&quot;) # hide
  ParameterAxis([&quot;offset&quot;;[&quot;p$i&quot; for i=1:order]]) # hide
end # hide
function polyRegression(xout::Vector, xin::Matrix, order::Integer)
  #code here
end

inAxes  = InDims(TimeAxis,miss=NaNMissing())
outAxes = OutDims((cube,pargs)-&gt;ParameterAxis(pargs[1]),miss=NaNMissing())
order = 2
mapCube(polyRegression, cube, 2, indims = inAxes, outdims = outAxes);</code></pre><p>The user can apply the function now using <code>mapCube(polyRegression, cubedata, regOrder)</code> where <code>regOrder</code> is the order of the Regression.</p><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.DAT.InDims" href="#ESDL.DAT.InDims"><code>ESDL.DAT.InDims</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">InDims(axisdesc)</code></pre><p>Creates a description of an Input Data Cube for cube operations. Takes a single   or a Vector/Tuple of axes as first argument. Axes can be specified by their   name (String), through an Axis type, or by passing a concrete axis.</p><ul><li><p>axisdesc: List of input axis names</p></li><li><p>miss: Representation of missing values for this input cube, must be a subtype of <a href="@ref">MissingRepr</a></p></li><li><p>include_axes: If set to <code>true</code> the array will be represented as an AxisArray inside the inner function, so that axes values can be accessed</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/DAT/registration.jl#L28-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.DAT.OutDims" href="#ESDL.DAT.OutDims"><code>ESDL.DAT.OutDims</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">OutDims(axisdesc;...)</code></pre><p>Creates a description of an Output Data Cube for cube operations. Takes a single   or a Vector/Tuple of axes as first argument. Axes can be specified by their   name (String), through an Axis type, or by passing a concrete axis.</p><ul><li><p>axisdesc: List of input axis names</p></li><li><p>miss: Representation of missing values for this input cube, must be a subtype of <a href="@ref">MissingRepr</a>, defaults to <code>DataArrayMissing</code></p></li><li><p>genOut: function to initialize the values of the output cube given its element type. Defaults to <code>zero</code></p></li><li><p>finalizeOut: function to finalize the values of an output cube, defaults to identity.</p></li><li><p>retCubeType: sepcifies the type of the return cube, can be <code>CubeMem</code> to force in-memory, <code>TempCube</code> to force disk storage, or <code>&quot;auto&quot;</code> to let the system decide.</p></li><li><p>outtype: force the output type to a specific type, defaults to <code>Any</code> which means that the element type of the first input cube is used</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/DAT/registration.jl#L52-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.DAT.mapCube" href="#ESDL.DAT.mapCube"><code>ESDL.DAT.mapCube</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mapCube(fun, cube, addargs...;kwargs)</code></pre><p>Map a given function <code>fun</code> over slices of the data cube <code>cube</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>max_cache=1e7</code> maximum size of blocks that are read into memory, defaults to approx 10Mb</p></li><li><p><code>outtype::DataType</code> output data type of the operation</p></li><li><p><code>indims::InDims List of input cube descriptors of type [</code>InDims`](@ref) for each input data cube</p></li><li><p><code>outdims::OutDims</code> List of output cube descriptors of type <a href="adding_new.html#ESDL.DAT.OutDims"><code>OutDims</code></a> for each output cube</p></li><li><p><code>no_ocean</code> should values containing ocean data be omitted, an integer specifying the cube whose input mask is used to determine land-sea points.</p></li><li><p><code>inplace</code> does the function write to an output array inplace or return a single value&gt; defaults to <code>true</code></p></li><li><p><code>ispar</code> boolean to determine if parallelisation should be applied, defaults to <code>true</code> if workers are available.</p></li><li><p><code>outfolder</code> a folder where the output cube is stroed, defaults to the result of <code>ESDLdir()</code></p></li><li><p><code>kwargs</code> additional keyword arguments passed to the inner function</p></li></ul><p>The first argument is always the function to be applied, the second is the input cube or a tuple input cubes if needed.</p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/DAT/DAT.jl#L297-L318">source</a></section><footer><hr/><a class="previous" href="plotting.html"><span class="direction">Previous</span><span class="title">Plotting</span></a><a class="next" href="iotools.html"><span class="direction">Next</span><span class="title">Loading and saving results</span></a></footer></article></body></html>
