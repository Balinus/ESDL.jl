<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Elementwise calculations · ESDL.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="ESDL.jl logo"/></a><h1>ESDL.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="thecube.html">The ESDL Data Cube</a></li><li><a class="toctext" href="cube_access.html">Accessing the Data Cube</a></li><li class="current"><a class="toctext" href="analysis.html">Elementwise calculations</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Analysis-1">Analysis</a></li><li><a class="toctext" href="#Seasonal-cycles-1">Seasonal cycles</a></li><li><a class="toctext" href="#Outlier-detection-1">Outlier detection</a></li><li><a class="toctext" href="#Simple-Statistics-1">Simple Statistics</a></li><li><a class="toctext" href="#Time-series-decomposition-1">Time series decomposition</a></li><li><a class="toctext" href="#Cube-transformations-1">Cube transformations</a></li><li><a class="toctext" href="#OnlineStats-1">OnlineStats</a></li></ul></li><li><a class="toctext" href="plotting.html">Plotting</a></li><li><a class="toctext" href="adding_new.html">Applying custom functions</a></li><li><a class="toctext" href="iotools.html">Loading and saving results</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="analysis.html">Elementwise calculations</a></li></ul><a class="edit-page" href="https://github.com/esa-esdl/ESDL.jl/blob/master/docs/src/analysis.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Elementwise calculations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Elementwise-calculations-1" href="#Elementwise-calculations-1">Elementwise calculations</a></h1><p>Doing elementwise calculations on the cube is generally done using the <code>map</code> function. So, if you want to multiply each single element of a data cube with 2, you could call <code>newcube = map(x-&gt;2*x, oldcube)</code>. This will not execute the computation immediately but on the fly during the next computation or plotting. Functions with multiple arguments can also be applied like in: <code>sumcube = map((x,y)-&gt;x+y, incube1, incube2)</code>. Which would calculate the sum of two data cubes.</p><p>We have also overloaded a list of commonly used operators (+,-,*,/, max,min) and functions (sin,cos,exp,log, log10) to apply on datacubes directly. So <code>newCube = (abs(cube1-cube2))</code> would work as expected.</p><h1><a class="nav-anchor" id="Analysis-1" href="#Analysis-1">Analysis</a></h1><p>The ESDL package comes with a list of predefined methods for statistical analysis. The functions are defined to work on specific axes, for example a function that removes the mean annual cycle will always extract one time series after the other from a cube, process them, store the results and concatenate the resulting time series to a new output cube. It does not matter which other axes are defined in the input cube, the function will simply loop over these.</p><p>The function will then be applied to the whole cube in a memory-efficient way, which means that chunks of data are read, processed and then saved in the output cube. Whether the output cube is a <code>MmapCube</code> or a <code>CubeMem</code> is decided by the system, depending on if the calculation is parallel, and how large the output cube is.</p><p>Here follows a list of analysis function included in this package. If you have implemented or wrapped a method that might be of interest to a broader community, please feel free to open a pull request.</p><h2><a class="nav-anchor" id="Seasonal-cycles-1" href="#Seasonal-cycles-1">Seasonal cycles</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.MSC.gapFillMSC-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.MSC.gapFillMSC-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.MSC.gapFillMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">gapFillMSC</code></pre><p>Fills missing values of each time series in a cube with the mean annual cycle.</p><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/MSC.jl#L38-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.MSC.getMSC-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.MSC.getMSC-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.MSC.getMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getMSC</code></pre><p>Returns the mean annual cycle from each time series.</p><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>MSC</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/MSC.jl#L60-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.MSC.getMedSC-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.MSC.getMedSC-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.MSC.getMedSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getMedMSC(c::AbstractCubeData)</code></pre><p>Returns the median annual cycle from each time series.</p><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>MSC</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/MSC.jl#L108-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.MSC.removeMSC-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.MSC.removeMSC-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.MSC.removeMSC</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">removeMSC(c::AbstractCubeData)</code></pre><p>Removes the mean annual cycle from each time series of a data cube.</p><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/MSC.jl#L24-L32">source</a></section><h2><a class="nav-anchor" id="Outlier-detection-1" href="#Outlier-detection-1">Outlier detection</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.Outlier.cubeAnomalies-Tuple{ESDL.Cubes.AbstractCubeData,Any,Any}" href="#ESDL.Proc.Outlier.cubeAnomalies-Tuple{ESDL.Cubes.AbstractCubeData,Any,Any}"><code>ESDL.Proc.Outlier.cubeAnomalies</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">cubeAnomalies(cube, methods, trainArray)</code></pre><p>A simple wrapper around the function <code>detectAnomalies!</code> from the <a href="https://github.com/milanflach/MultivariateAnomalies.jl">MultivariateAnomalies</a> package.</p><ul><li><p><code>cube</code> data cube with a axes: <code>TimeAxis</code>, <code>VariableAxis</code></p></li><li><p><code>methods</code> vector of methods to be applied, choose from: <code>KDE</code>,<code>T2</code>,<code>REC</code>,<code>KNN-Gamma</code>,<code>KNN-Delta</code>,<code>SVDD</code>,<code>KNFST</code></p></li><li><p><code>trainArray</code> a matrix of <code>nsample</code> x <code>nvar</code>, to estimate the training parameters for the model. Ideally does not contain any extreme values</p></li></ul><p><strong>Input Axes</strong> <code>TimeAxis</code>, <code>Variable</code>axis</p><p><strong>Output Axes</strong> <code>TimeAxis</code>, <code>Method</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/Outlier.jl#L15-L28">source</a></section><h2><a class="nav-anchor" id="Simple-Statistics-1" href="#Simple-Statistics-1">Simple Statistics</a></h2><p>Another typical use case is the application of basic statistics like <code>sum</code>, <code>mean</code> and <code>std</code> applied on one or more cube axes. We overload the method <code>mapslices</code> for data cubes,   </p><p>The main difference to the function exported in Base is that the dimensions to be sliced over are given by name and not by dimension index. For example,</p><pre><code class="language-julia">mapslices(mean, cube,(&quot;Lon&quot;,&quot;Lat&quot;))</code></pre><p>will compute the mean over each spatial map contained in the data cube. Please that that the <code>mapslices</code> function will execute the function once with random number input to determine the shape of the returned values and then pre-allocate the output array. So keep this in mind when your function has some side-effects. Note also that although the <code>mapslices</code> function should <em>just work</em> in most cases, it is advised to know read about the <a href="adding_new.html#ESDL.DAT.mapCube"><code>mapCube</code></a> function in <a href="adding_new.html#Applying-custom-functions-1">Applying custom functions</a> which gives you much more detailed control over the mapping operation.</p><p>Applying these functions makes sense if the slices one wants to reduce fit in memory. However, if one wants to calculate some statistics on e.g. a time<em>lon</em>lat cube, one would preferably call one of the <a href="analysis.html#OnlineStats-1">OnlineStats</a> methods.  </p><p>Additional simple statistics functions are:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.Stats.normalizeTS-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.Stats.normalizeTS-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.Stats.normalizeTS</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">normalizeTS(c::AbstractCubeData)</code></pre><p>Normalize a time series to zeros mean and unit variance</p><p><strong>Input Axes</strong> <code>TimeAxis</code></p><p><strong>Output Axes</strong> <code>TimeAxis</code></p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/Stats.jl#L10-L18">source</a></section><h2><a class="nav-anchor" id="Time-series-decomposition-1" href="#Time-series-decomposition-1">Time series decomposition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.TSDecomposition.filterTSFFT-Tuple{ESDL.Cubes.AbstractCubeData}" href="#ESDL.Proc.TSDecomposition.filterTSFFT-Tuple{ESDL.Cubes.AbstractCubeData}"><code>ESDL.Proc.TSDecomposition.filterTSFFT</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">filterTSFFT</code></pre><p>Filter each time series using a Fourier filter and return the decomposed series in 4 time windows (Trend, Long-Term Variability, Annual Cycle, Fast Oscillations)</p><p><strong>Input Axes</strong> <code>Time</code>axis</p><p><strong>Output Axes</strong> <code>Time</code>axis, <code>TimeScale</code>axis</p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/TSDecomposition.jl#L22-L32">source</a></section><h2><a class="nav-anchor" id="Cube-transformations-1" href="#Cube-transformations-1">Cube transformations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.CubeIO.exportcube-Tuple{ESDL.Cubes.AbstractCubeData,String}" href="#ESDL.Proc.CubeIO.exportcube-Tuple{ESDL.Cubes.AbstractCubeData,String}"><code>ESDL.Proc.CubeIO.exportcube</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">exportcube(r::AbstractCubeData,filename::String)</code></pre><p>Saves a cube object to a portable NetCDF file in <code>filename</code>.</p><p>When saving, every RangeAxis will be converted to an axis in the NetCDF cube, while every categorical axis will be represented by a different variable inside the resulting file. Dimensions will be ordered according to the <code>priorities</code> keyword argument, which defaults to <code>Dict(&quot;LON&quot;=&gt;1,&quot;LAT&quot;=&gt;2,&quot;TIME&quot;=&gt;3)</code>, which means that the file will be stored with longitudes varuing fastest. </p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/CubeIO.jl#L146-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.CubeIO.extractLonLats-Tuple{ESDL.Cubes.AbstractCubeData,Array{T,2} where T}" href="#ESDL.Proc.CubeIO.extractLonLats-Tuple{ESDL.Cubes.AbstractCubeData,Array{T,2} where T}"><code>ESDL.Proc.CubeIO.extractLonLats</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">extractLonLats(c::AbstractCubeData,pl::Matrix)</code></pre><p>Extracts a list of longitude/latitude coordinates from a data cube. The coordinates are specified through the matrix <code>pl</code> where <code>size(pl)==(N,2)</code> and N is the number of extracted coordinates. Returns a data cube without <code>LonAxis</code> and <code>LatAxis</code> but with a <code>SpatialPointAxis</code> containing the input locations.</p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/CubeIO.jl#L63-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.CubeIO.sampleLandPoints" href="#ESDL.Proc.CubeIO.sampleLandPoints"><code>ESDL.Proc.CubeIO.sampleLandPoints</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sampleLandPoints(cube, nsample;nomissing=false)</code></pre><p>Get an area-weighted sample from all non-ocean grid cells. This will return a new Cube where the <code>LonAxis</code> and <code>LatAxis</code> are condensed into a single <code>SpatialPointAxis</code> of length <code>nsample</code>. If <code>nomissing=true</code> only grid cells will be selected which don&#39;t contain any missing values. This makes sense for gap-filled cubes to make sure that grid cells with systematic seasonal gaps are not selected in the sample.</p></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/CubeIO.jl#L89-L97">source</a></section><h2><a class="nav-anchor" id="OnlineStats-1" href="#OnlineStats-1">OnlineStats</a></h2><p>It is possible to directly apply statistics included in the <a href="https://github.com/joshday/OnlineStats.jl">OnlineStats.jl package</a> on the data cube. This makes it possible to calculate statistics on data too big to fit into memory. The general syntax is</p><pre><code class="language-julia">mapCube(f ,cube; by=CubeAxis[], cfun=identity, outAxis=nothing,kwargs...)</code></pre><p>where <code>f</code> is an OnlineStat data type and <code>cube</code> is the cube you want to apply the statistics to. By default this function will reduce all values over all axes of the cube, so if you want to do statistics by a certain axis, it has to be specified using the <code>by</code> keyword argument. <code>by</code> accepts a vector of axes types and up to one datacube that can serve as a mask. If such a data cube is supplied, the statistics are split by the unique values in the mask. One can pass a function <code>cfun</code> that transforms the mask values into an index in the range <code>1..N</code> that defines the    index where the new value is going to be put to. If a mask is supplied, it must have either a <code>labels</code> property, which is a <code>Dict{T,String}</code> mapping the numerical mask value to the value name. Alternatively on can supply an <code>outAxis</code> argument that describes the resulting output axis.</p><p>This all gets clearer with two small examples. suppose we want to calculate the mean of GPP, NEE and TER under the condition that Tair&lt;280K and Tair&gt;280K over all time steps and grid cells. This is achieved through the following lines of code:</p><pre><code class="language-julia">import OnlineStats
lons  = (30,31)
lats  = (50,51)
vars  = [&quot;gross_primary_productivity&quot;,&quot;net_ecosystem_exchange&quot;,&quot;terrestrial_ecosystem_respiration&quot;]
t     = getCubeData(ds,variable=&quot;air_temperature_2m&quot;,longitude=lons,latitude=lats)
cube  = getCubeData(ds,variable=vars,longitude=lons,latitude=lats)

splitTemp(t) = ifelse(t&gt;280,2,1)                            # Define the classification function
outAxis      = CategoricalAxis(&quot;TempClass&quot;,[&quot;&lt; 7C&quot;,&quot;&gt;7C&quot;])  # A two-length output axis, because there are two possible values
mT    = mapCube(OnlineStats.Mean,cube,by=[t,VariableAxis], cfun=splitTemp, outAxis=outAxis) # Of course we want to split by variable, too

using ESDLPlots
plotXY(mT,xaxis=&quot;var&quot;,group=&quot;tempclass&quot;)</code></pre><script>(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var VNode = require('vtree/vnode');
var svg = require('virtual-hyperscript/svg');
var VText = require('vtree/vtext');
var VPatch = require('vtree/vpatch');
var diff = require('virtual-dom/diff');
var patch = require('virtual-dom/patch');
var createElement = require('virtual-dom/create-element');
var nodeIndex = require('./node-index');
var patchVNode = require('./patch-vnode');
var isArray = require('x-is-array');
var isVPatch = require('./is-vpatch');

var P = Patchwork = {
    nodes: {},
    debug: false,
    Node: function (id, jlNode, el, renderOpts) {
        if (typeof(el) === "undefined") {
            el = document.getElementById(id)
        }
        this.id = id
        this.renderOptions = renderOpts
        if (jlNode) {
            // Note: makes this.root
            var vnode = P.makeVNode(jlNode)
            P.log("makeVNode: ", jlNode, "=>", vnode)
            this.mount(vnode, el, renderOpts)
        }
        P.nodes[id] = this
    },
    NAMESPACES: {
        "xhtml": null,
        "svg": "http://www.w3.org/2000/svg",
        null: null,
        undefined: null
    },
    refDiff: function (a, b, p) {
        var a = P.makeVNode(a)
            b = P.makeVNode(b)
            p = P.makeVPatches(a, p)
        console.log(p, diff(a, b));
    },
    massageProps: function (props) {
        if ("attributes" in props) {
            // we can't send undefined over JSON, so we turn nulls into undefs
            // so that VDom calls removeAttribute on the DOM node.
            //console.log("attributes ", props.attributes)
            for (var attr in props.attributes) {
                if (!props.attributes.hasOwnProperty(attr)) {
                    continue
                }
                if (props.attributes[attr] === null) {
                //console.log("remove ", attr, props.attributes[attr]);
                    props.attributes[attr] = undefined
                }
            }
        }
        return P.setupHooks(props);
    },
    hooks: {},
    register_hook: function (hook, f) {
        P.hooks[hook] = f;
    },
    setupHooks: function (props) {
        if (typeof props !== "object" || props == null) {
            return props;
        } else if (props && "_hook" in props) {
            if (props._hook in P.hooks) {
                v = P.hooks[props._hook](P.setupHooks(props.val));
                return v
            } else {
                console.warn("Unknown hook " + props._hook + "use Patchwork.register_hook to set it up")
                return undefined
            }
        } else {
            for (var k in props) {
                props[k] = P.setupHooks(props[k]);
            }
            return props;
        }
    },
    makeVNode: function (jlNode) {
        if ('txt' in jlNode) return new VText(jlNode.txt);
        var children = [],
            props = P.massageProps(jlNode.p || {})

        if (jlNode.c) {
            for (var i = 0, l = jlNode.c.length; i < l; i++) {
                children[i] = P.makeVNode(jlNode.c[i])
            }
        }

        if (jlNode.n === "svg") {
            return svg(jlNode.t, props, children)
        } else {
            var key = null
            if (props && props.key) {
                key = props.key
                delete props.key
            }
            return new VNode(jlNode.t,
                             props,
                             children,
                             key,
                             P.NAMESPACES[jlNode.n]);
        }
    },
    makeVPatches: function (root, jlPatches) {
        var indices = [];
        var vpatches = {a: root}
        for (var idx in jlPatches) {
            if (!jlPatches.hasOwnProperty(idx)) {
                continue
            }
            indices.push(Number(idx))
        }
        nodes = nodeIndex(root, indices)

        for (var idx in jlPatches) {
            vpatches[idx] = P.makeVPatch(nodes[idx], jlPatches[idx]);
        }
        return vpatches
    },
    makeVPatch: function (vnode, jlPatch) {
        if (isArray(jlPatch)) {
            // multiple patches to the same VNode
            var ps = [];
            for (var i=0, l=jlPatch.length; i < l; i++) {
                ps[i] = P.makeVPatch(vnode, jlPatch[i])
            }
            return ps
        }

        var type, patch;
        for (var k in jlPatch) {
            type = k;
            patch = jlPatch[k];
            break; // inorite?
        }

        function vpatch(p) { return new VPatch(type, vnode, p); }

        switch (Number(type)) {
        case VPatch.VTEXT:
            return vpatch(new VText(patch));
        case VPatch.VNODE:
            return vpatch(P.makeVNode(patch));
        case VPatch.PROPS:
            patch = P.massageProps(patch)
            if (vnode.namespace === P.NAMESPACES["svg"]) {
                patch = svg('dummy', patch, []).properties
            }
            return vpatch(patch);
        case VPatch.ORDER:
            return vpatch(patch);
        case VPatch.INSERT:
            return vpatch(P.makeVNode(patch));
        case VPatch.REMOVE:
            return vpatch(null);
        default:
            return null;
        }
    },
    log: function () {
        if (console && P.debug) {
            console.log.apply(console, arguments);
        }
    }
}

Patchwork.Node.prototype = {
    mount: function (vnode, outer, renderOpts) {
        var el = createElement(vnode, renderOpts);
        P.log("createElement: ", vnode, "=>", el)
        outer.appendChild(el)
        this.element = el
        this.root = vnode;
        return el;
    },
    applyPatch: function (vpatches) {
        // apply patch to DOM nodes
        if (!isVPatch(vpatches)) {
            vpatches = P.makeVPatches(this.root, vpatches)
        }
        this.element = patch(this.element, vpatches, this.renderOptions)
        this.root = patchVNode(this.root, vpatches)
    }
}

function init(nb, cue) {
    if (!Patchwork.inited) {
        try {
            console.log("attempting Patchwork setup, cue:", cue)
            var commMgr =  nb.kernel.comm_manager;
            commMgr.register_target("PatchStream", function (comm, msg) {
                var nodeId = msg.content.data.pwid;
                comm.on_msg(function (msg) {
                    var node = P.nodes[nodeId],
                        patches = msg.content.data
                    node.applyPatch(patches)
                    P.log("received patches", patches)
                });
            });
            Patchwork.inited = true;
        } catch (e) {
            Patchwork.inited = false;
            console.log("ERROR initializing patchwork: ", e);
            console.log("attempting failed, cue:", cue)
        }
    }
}

// IJulia setup
if (typeof(window.IPython) !== "undefined") {
    init(IPython.notebook, "immediate");
    $(document).ready(function () { init(IPython.notebook, "document ready"); });
    $([IPython.events]).on("kernel_ready.Kernel kernel_created.Kernel", function (evt, nb) {
        init(nb, "kernel start")
    })
}

window.Patchwork = Patchwork;

},{"./is-vpatch":2,"./node-index":3,"./patch-vnode":58,"virtual-dom/create-element":5,"virtual-dom/diff":6,"virtual-dom/patch":23,"virtual-hyperscript/svg":47,"vtree/vnode":53,"vtree/vpatch":54,"vtree/vtext":55,"x-is-array":56}],2:[function(require,module,exports){
var version = require("vtree/version")

module.exports = isVirtualPatch

function isVirtualPatch(x) {
    return x && x.type === "VirtualPatch" && x.version === version
}

},{"vtree/version":52}],3:[function(require,module,exports){
module.exports = nodeIndex

function nodeIndex(tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(tree, indices, nodes, 0)
    }
}

function recurse(tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (tree) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = tree
        }

        var vChildren = tree.children

        if (vChildren) {

            for (var i = 0; i < vChildren.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i]
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    } else {
        rootIndex
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],4:[function(require,module,exports){
module.exports = isObject

function isObject(x) {
    return typeof x === "object" && x !== null
}

},{}],5:[function(require,module,exports){
var createElement = require("vdom/create-element")

module.exports = createElement

},{"vdom/create-element":8}],6:[function(require,module,exports){
var diff = require("vtree/diff")

module.exports = diff

},{"vtree/diff":14}],7:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("vtree/is-vhook")

module.exports = applyProperties

function applyProperties(node, props, previous, renderOptions) {
    var domNode = renderOptions && renderOptions.extractNode ?
            renderOptions.extractNode(node) : node

    for (var propName in props) {
        var propValue = props[propName]

        if (propValue === undefined) {
            removeProperty(domNode, props, previous, propName);
        } else if (isHook(propValue)) {
            propValue.hook(domNode,
                propName,
                previous ? previous[propName] : undefined)
        } else {
            if (isObject(propValue)) {
                patchObject(domNode, props, previous, propName, propValue);
            } else if (propValue !== undefined) {
                domNode[propName] = propValue
            }
        }
    }
}

function removeProperty(node, props, previous, propName) {
    if (previous) {
        var previousValue = previous[propName]

        if (!isHook(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName)
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = ""
                }
            } else if (typeof previousValue === "string") {
                node[propName] = ""
            } else {
                node[propName] = null
            }
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName]

            if (attrValue === undefined) {
                node.removeAttribute(attrName)
            } else {
                node.setAttribute(attrName, attrValue)
            }
        }

        return
    }

    if(previousValue && isObject(previousValue) &&
        getPrototype(previousValue) !== getPrototype(propValue)) {
        node[propName] = propValue
        return
    }

    if (!isObject(node[propName])) {
        node[propName] = {}
    }

    var replacer = propName === "style" ? "" : undefined

    for (var k in propValue) {
        var value = propValue[k]
        node[propName][k] = (value === undefined) ? replacer : value
    }
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

},{"is-object":4,"vtree/is-vhook":17}],8:[function(require,module,exports){
var document = require("global/document")

var applyProperties = require("./apply-properties")

var isVNode = require("vtree/is-vnode")
var isVText = require("vtree/is-vtext")
var isWidget = require("vtree/is-widget")
var handleThunk = require("vtree/handle-thunk")

module.exports = createElement

function id(x) { return x }

function createElement(vnode, opts) {

    var doc = opts ? opts.document || document : document
    var warn = opts ? opts.warn : null

    vnode = handleThunk(vnode).a

    if (isWidget(vnode)) {
        return vnode.init()
    } else if (isVText(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode)
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName, vnode.properties.is) :
        doc.createElementNS(vnode.namespace, vnode.tagName)

    var props = vnode.properties
    applyProperties(node, props, null, opts)

    var children = vnode.children

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts)
        if (childNode) {
            node.appendChild(childNode)
        }
    }

    return node
}

},{"./apply-properties":7,"global/document":10,"vtree/handle-thunk":15,"vtree/is-vnode":18,"vtree/is-vtext":19,"vtree/is-widget":20}],9:[function(require,module,exports){
// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {}

module.exports = domIndex

function domIndex(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode
        }

        var vChildren = tree.children

        if (vChildren) {

            var childNodes = rootNode.childNodes

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i] || noChild
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],10:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"min-document":60}],11:[function(require,module,exports){
var applyProperties = require("./apply-properties")

var isWidget = require("vtree/is-widget")
var VPatch = require("vtree/vpatch")

var render = require("./create-element")
var updateWidget = require("./update-widget")

module.exports = applyPatch

function applyPatch(vpatch, domNode, renderOptions) {
    var type = vpatch.type
    var vNode = vpatch.vNode
    var patch = vpatch.patch

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch.ORDER:
            reorderChildren(domNode, patch)
            return domNode
        case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties, renderOptions)
            return domNode
        case VPatch.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode

    if (parentNode) {
        parentNode.removeChild(domNode)
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = render(vNode, renderOptions)

    if (parentNode) {
        parentNode.appendChild(newNode)
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text)
        newNode = domNode
    } else {
        var parentNode = domNode.parentNode
        newNode = render(vText, renderOptions)

        if (parentNode) {
            parentNode.replaceChild(newNode, domNode)
        }
    }

    destroyWidget(domNode, leftVNode)

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    if (updateWidget(leftVNode, widget)) {
        return widget.update(leftVNode, domNode) || domNode
    }

    var parentNode = domNode.parentNode
    var newWidget = render(widget, renderOptions)

    if (parentNode) {
        parentNode.replaceChild(newWidget, domNode)
    }

    destroyWidget(domNode, leftVNode)

    return newWidget
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode
    var newNode = render(vNode, renderOptions)

    if (parentNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    destroyWidget(domNode, leftVNode)

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget(w)) {
        w.destroy(domNode)
    }
}

function reorderChildren(domNode, bIndex) {
    var children = []
    var childNodes = domNode.childNodes
    var len = childNodes.length
    var i
    var reverseIndex = bIndex.reverse

    for (i = 0; i < len; i++) {
        children.push(domNode.childNodes[i])
    }

    var insertOffset = 0
    var move
    var node
    var insertNode
    for (i = 0; i < len; i++) {
        move = bIndex[i]
        if (move !== undefined && move !== i) {
            // the element currently at this index will be moved later so increase the insert offset
            if (reverseIndex[i] > i) {
                insertOffset++
            }

            node = children[move]
            insertNode = childNodes[i + insertOffset] || null
            if (node !== insertNode) {
                domNode.insertBefore(node, insertNode)
            }

            // the moved element came from the front of the array so reduce the insert offset
            if (move < i) {
                insertOffset--
            }
        }

        // element at this index is scheduled to be removed so increase insert offset
        if (i in bIndex.removes) {
            insertOffset++
        }
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        console.log(oldRoot)
        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
    }

    return newRoot;
}

},{"./apply-properties":7,"./create-element":8,"./update-widget":13,"vtree/is-widget":20,"vtree/vpatch":22}],12:[function(require,module,exports){
var document = require("global/document")
var isArray = require("x-is-array")

var domIndex = require("./dom-index")
var patchOp = require("./patch-op")
module.exports = patch

function patch(rootNode, patches, renderOptions) {
    return patchRecursive(rootNode, patches, renderOptions)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches)

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices)
    var ownerDocument = rootNode.ownerDocument

    if (!renderOptions) {
        renderOptions = {}
        if (ownerDocument !== document) {
            renderOptions.document = ownerDocument
        }
    }

    if (!renderOptions.patch) {
        renderOptions.patch = patchRecursive
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i]
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions)
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode

    if (isArray(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions)

            if (domNode === rootNode) {
                rootNode = newNode
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions)

        if (domNode === rootNode) {
            rootNode = newNode
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = []

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key))
        }
    }

    return indices
}

},{"./dom-index":9,"./patch-op":11,"global/document":10,"x-is-array":56}],13:[function(require,module,exports){
var isWidget = require("vtree/is-widget")

module.exports = updateWidget

function updateWidget(a, b) {
    if (isWidget(a) && isWidget(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

},{"vtree/is-widget":20}],14:[function(require,module,exports){
var isArray = require("x-is-array")
var isObject = require("is-object")

var VPatch = require("./vpatch")
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")
var handleThunk = require("./handle-thunk")

module.exports = diff

function diff(a, b) {
    var patch = { a: a }
    walk(a, b, patch, 0)
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        if (isThunk(a) || isThunk(b)) {
            thunks(a, b, patch, index)
        } else {
            hooks(b, patch, index)
        }
        return
    }

    var apply = patch[index]

    if (b == null) {
        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
        destroyWidgets(a, patch, index)
    } else if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index)
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties, b.hooks)
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch))
                }
                apply = diffChildren(a, b, patch, apply, index)
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
                destroyWidgets(a, patch, index)
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
            destroyWidgets(a, patch, index)
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
            destroyWidgets(a, patch, index)
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
        }
    } else if (isWidget(b)) {
        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))

        if (!isWidget(a)) {
            destroyWidgets(a, patch, index)
        }
    }

    if (apply) {
        patch[index] = apply
    }
}

function diffProps(a, b, hooks) {
    var diff

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {}
            diff[aKey] = undefined
        }

        var aValue = a[aKey]
        var bValue = b[aKey]

        if (hooks && aKey in hooks) {
            diff = diff || {}
            diff[aKey] = bValue
        } else {
            if (isObject(aValue) && isObject(bValue)) {
                if (getPrototype(bValue) !== getPrototype(aValue)) {
                    diff = diff || {}
                    diff[aKey] = bValue
                } else {
                    var objectDiff = diffProps(aValue, bValue)
                    if (objectDiff) {
                        diff = diff || {}
                        diff[aKey] = objectDiff
                    }
                }
            } else if (aValue !== bValue) {
                diff = diff || {}
                diff[aKey] = bValue
            }
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {}
            diff[bKey] = b[bKey]
        }
    }

    return diff
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children
    var bChildren = reorder(aChildren, b.children)

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i]
        var rightNode = bChildren[i]
        index += 1

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode))
            }
        } else if (!rightNode) {
            if (leftNode) {
                // Excess nodes in a need to be removed
                patch[index] = new VPatch(VPatch.REMOVE, leftNode, null)
                destroyWidgets(leftNode, patch, index)
            }
        } else {
            walk(leftNode, rightNode, patch, index)
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count
        }
    }

    if (bChildren.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(VPatch.ORDER, a, bChildren.moves))
    }

    return apply
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = new VPatch(VPatch.REMOVE, vNode, null)
        }
    } else if (isVNode(vNode) && vNode.hasWidgets) {
        var children = vNode.children
        var len = children.length
        for (var i = 0; i < len; i++) {
            var child = children[i]
            index += 1

            destroyWidgets(child, patch, index)

            if (isVNode(child) && child.count) {
                index += child.count
            }
        }
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b);
    var thunkPatch = diff(nodes.a, nodes.b)
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true;
        }
    }

    return false;
}

// Execute hooks when two nodes are identical
function hooks(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = new VPatch(VPatch.PROPS, vNode.hooks, vNode.hooks)
        }

        if (vNode.descendantHooks) {
            var children = vNode.children
            var len = children.length
            for (var i = 0; i < len; i++) {
                var child = children[i]
                index += 1

                hooks(child, patch, index)

                if (isVNode(child) && child.count) {
                    index += child.count
                }
            }
        }
    }
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {

    var bKeys = keyIndex(bChildren)

    if (!bKeys) {
        return bChildren
    }

    var aKeys = keyIndex(aChildren)

    if (!aKeys) {
        return bChildren
    }

    var bMatch = {}, aMatch = {}

    for (var key in bKeys) {
        bMatch[bKeys[key]] = aKeys[key]
    }

    for (var key in aKeys) {
        aMatch[aKeys[key]] = bKeys[key]
    }

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen
    var shuffle = []
    var freeIndex = 0
    var i = 0
    var moveIndex = 0
    var moves = {}
    var removes = moves.removes = {}
    var reverse = moves.reverse = {}
    var hasMoves = false

    while (freeIndex < len) {
        var move = aMatch[i]
        if (move !== undefined) {
            shuffle[i] = bChildren[move]
            if (move !== moveIndex) {
                moves[move] = moveIndex
                reverse[moveIndex] = move
                hasMoves = true
            }
            moveIndex++
        } else if (i in aMatch) {
            shuffle[i] = undefined
            removes[i] = moveIndex++
            hasMoves = true
        } else {
            while (bMatch[freeIndex] !== undefined) {
                freeIndex++
            }

            if (freeIndex < len) {
                var freeChild = bChildren[freeIndex]
                if (freeChild) {
                    shuffle[i] = freeChild
                    if (freeIndex !== moveIndex) {
                        hasMoves = true
                        moves[freeIndex] = moveIndex
                        reverse[moveIndex] = freeIndex
                    }
                    moveIndex++
                }
                freeIndex++
            }
        }
        i++
    }

    if (hasMoves) {
        shuffle.moves = moves
    }

    return shuffle
}

function keyIndex(children) {
    var i, keys

    for (i = 0; i < children.length; i++) {
        var child = children[i]

        if (child.key !== undefined) {
            keys = keys || {}
            keys[child.key] = i
        }
    }

    return keys
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray(apply)) {
            apply.push(patch)
        } else {
            apply = [apply, patch]
        }

        return apply
    } else {
        return patch
    }
}

},{"./handle-thunk":15,"./is-thunk":16,"./is-vnode":18,"./is-vtext":19,"./is-widget":20,"./vpatch":22,"is-object":4,"x-is-array":56}],15:[function(require,module,exports){
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")

module.exports = handleThunk

function handleThunk(a, b) {
    var renderedA = a
    var renderedB = b

    if (isThunk(b)) {
        renderedB = renderThunk(b, a)
    }

    if (isThunk(a)) {
        renderedA = renderThunk(a, null)
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous)
    }

    if (!(isVNode(renderedThunk) ||
            isVText(renderedThunk) ||
            isWidget(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

},{"./is-thunk":16,"./is-vnode":18,"./is-vtext":19,"./is-widget":20}],16:[function(require,module,exports){
module.exports = isThunk

function isThunk(t) {
    return t && t.type === "Thunk"
}

},{}],17:[function(require,module,exports){
module.exports = isHook

function isHook(hook) {
    return hook && typeof hook.hook === "function" &&
        !hook.hasOwnProperty("hook")
}

},{}],18:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualNode

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version
}

},{"./version":21}],19:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualText

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version
}

},{"./version":21}],20:[function(require,module,exports){
module.exports = isWidget

function isWidget(w) {
    return w && w.type === "Widget"
}

},{}],21:[function(require,module,exports){
module.exports = "1"

},{}],22:[function(require,module,exports){
var version = require("./version")

VirtualPatch.NONE = 0
VirtualPatch.VTEXT = 1
VirtualPatch.VNODE = 2
VirtualPatch.WIDGET = 3
VirtualPatch.PROPS = 4
VirtualPatch.ORDER = 5
VirtualPatch.INSERT = 6
VirtualPatch.REMOVE = 7
VirtualPatch.THUNK = 8

module.exports = VirtualPatch

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type)
    this.vNode = vNode
    this.patch = patch
}

VirtualPatch.prototype.version = version
VirtualPatch.prototype.type = "VirtualPatch"

},{"./version":21}],23:[function(require,module,exports){
var patch = require("vdom/patch")

module.exports = patch

},{"vdom/patch":12}],24:[function(require,module,exports){
module.exports = AttributeHook;

function AttributeHook(value) {
    if (!(this instanceof AttributeHook)) {
        return new AttributeHook(value);
    }

    this.value = value;
}

AttributeHook.prototype.hook = function (node, prop, prev) {
    if (prev && prev.value === this.value) {
        return;
    }

    node.setAttributeNS(null, prop, this.value)
}

},{}],25:[function(require,module,exports){
var DataSet = require("data-set")

module.exports = DataSetHook;

function DataSetHook(value) {
    if (!(this instanceof DataSetHook)) {
        return new DataSetHook(value);
    }

    this.value = value;
}

DataSetHook.prototype.hook = function (node, propertyName) {
    var ds = DataSet(node)
    var propName = propertyName.substr(5)

    ds[propName] = this.value;
};

},{"data-set":30}],26:[function(require,module,exports){
var DataSet = require("data-set")

module.exports = DataSetHook;

function DataSetHook(value) {
    if (!(this instanceof DataSetHook)) {
        return new DataSetHook(value);
    }

    this.value = value;
}

DataSetHook.prototype.hook = function (node, propertyName) {
    var ds = DataSet(node)
    var propName = propertyName.substr(3)

    ds[propName] = this.value;
};

},{"data-set":30}],27:[function(require,module,exports){
module.exports = SoftSetHook;

function SoftSetHook(value) {
    if (!(this instanceof SoftSetHook)) {
        return new SoftSetHook(value);
    }

    this.value = value;
}

SoftSetHook.prototype.hook = function (node, propertyName) {
    if (node[propertyName] !== this.value) {
        node[propertyName] = this.value;
    }
};

},{}],28:[function(require,module,exports){
var VNode = require("vtree/vnode.js")
var VText = require("vtree/vtext.js")
var isVNode = require("vtree/is-vnode")
var isVText = require("vtree/is-vtext")
var isWidget = require("vtree/is-widget")
var isHook = require("vtree/is-vhook")
var isVThunk = require("vtree/is-thunk")
var TypedError = require("error/typed")

var parseTag = require("./parse-tag.js")
var softSetHook = require("./hooks/soft-set-hook.js")
var dataSetHook = require("./hooks/data-set-hook.js")
var evHook = require("./hooks/ev-hook.js")

var UnexpectedVirtualElement = TypedError({
    type: "virtual-hyperscript.unexpected.virtual-element",
    message: "Unexpected virtual child passed to h().\n" +
        "Expected a VNode / Vthunk / VWidget / string but:\n" +
        "got a {foreignObjectStr}.\n" +
        "The parent vnode is {parentVnodeStr}.\n" +
        "Suggested fix: change your `h(..., [ ... ])` callsite.",
    foreignObjectStr: null,
    parentVnodeStr: null,
    foreignObject: null,
    parentVnode: null
})

module.exports = h

function h(tagName, properties, children) {
    var childNodes = []
    var tag, props, key, namespace

    if (!children && isChildren(properties)) {
        children = properties
        props = {}
    }

    props = props || properties || {}
    tag = parseTag(tagName, props)

    // support keys
    if ("key" in props) {
        key = props.key
        props.key = undefined
    }

    // support namespace
    if ("namespace" in props) {
        namespace = props.namespace
        props.namespace = undefined
    }

    // fix cursor bug
    if (tag === "input" &&
        "value" in props &&
        props.value !== undefined &&
        !isHook(props.value)
    ) {
        props.value = softSetHook(props.value)
    }

    var keys = Object.keys(props)
    var propName, value
    for (var j = 0; j < keys.length; j++) {
        propName = keys[j]
        value = props[propName]
        if (isHook(value)) {
            continue
        }

        // add data-foo support
        if (propName.substr(0, 5) === "data-") {
            props[propName] = dataSetHook(value)
        }

        // add ev-foo support
        if (propName.substr(0, 3) === "ev-") {
            props[propName] = evHook(value)
        }
    }

    if (children !== undefined && children !== null) {
        addChild(children, childNodes, tag, props)
    }


    var node = new VNode(tag, props, childNodes, key, namespace)

    return node
}

function addChild(c, childNodes, tag, props) {
    if (typeof c === "string") {
        childNodes.push(new VText(c))
    } else if (isChild(c)) {
        childNodes.push(c)
    } else if (Array.isArray(c)) {
        for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props)
        }
    } else if (c === null || c === undefined) {
        return
    } else {
        throw UnexpectedVirtualElement({
            foreignObjectStr: JSON.stringify(c),
            foreignObject: c,
            parentVnodeStr: JSON.stringify({
                tagName: tag,
                properties: props
            }),
            parentVnode: {
                tagName: tag,
                properties: props
            }
        })
    }
}

function isChild(x) {
    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x)
}

function isChildren(x) {
    return typeof x === "string" || Array.isArray(x) || isChild(x)
}

},{"./hooks/data-set-hook.js":25,"./hooks/ev-hook.js":26,"./hooks/soft-set-hook.js":27,"./parse-tag.js":46,"error/typed":37,"vtree/is-thunk":38,"vtree/is-vhook":39,"vtree/is-vnode":40,"vtree/is-vtext":41,"vtree/is-widget":42,"vtree/vnode.js":44,"vtree/vtext.js":45}],29:[function(require,module,exports){
module.exports = createHash

function createHash(elem) {
    var attributes = elem.attributes
    var hash = {}

    if (attributes === null || attributes === undefined) {
        return hash
    }

    for (var i = 0; i < attributes.length; i++) {
        var attr = attributes[i]

        if (attr.name.substr(0,5) !== "data-") {
            continue
        }

        hash[attr.name.substr(5)] = attr.value
    }

    return hash
}

},{}],30:[function(require,module,exports){
var createStore = require("weakmap-shim/create-store")
var Individual = require("individual")

var createHash = require("./create-hash.js")

var hashStore = Individual("__DATA_SET_WEAKMAP@3", createStore())

module.exports = DataSet

function DataSet(elem) {
    var store = hashStore(elem)

    if (!store.hash) {
        store.hash = createHash(elem)
    }

    return store.hash
}

},{"./create-hash.js":29,"individual":31,"weakmap-shim/create-store":32}],31:[function(require,module,exports){
(function (global){
var root = typeof window !== 'undefined' ?
    window : typeof global !== 'undefined' ?
    global : {};

module.exports = Individual

function Individual(key, value) {
    if (root[key]) {
        return root[key]
    }

    Object.defineProperty(root, key, {
        value: value
        , configurable: true
    })

    return value
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],32:[function(require,module,exports){
var hiddenStore = require('./hidden-store.js');

module.exports = createStore;

function createStore() {
    var key = {};

    return function (obj) {
        if (typeof obj !== 'object' || obj === null) {
            throw new Error('Weakmap-shim: Key must be object')
        }

        var store = obj.valueOf(key);
        return store && store.identity === key ?
            store : hiddenStore(obj, key);
    };
}

},{"./hidden-store.js":33}],33:[function(require,module,exports){
module.exports = hiddenStore;

function hiddenStore(obj, key) {
    var store = { identity: key };
    var valueOf = obj.valueOf;

    Object.defineProperty(obj, "valueOf", {
        value: function (value) {
            return value !== key ?
                valueOf.apply(this, arguments) : store;
        },
        writable: true
    });

    return store;
}

},{}],34:[function(require,module,exports){
module.exports = function(obj) {
    if (typeof obj === 'string') return camelCase(obj);
    return walk(obj);
};

function walk (obj) {
    if (!obj || typeof obj !== 'object') return obj;
    if (isDate(obj) || isRegex(obj)) return obj;
    if (isArray(obj)) return map(obj, walk);
    return reduce(objectKeys(obj), function (acc, key) {
        var camel = camelCase(key);
        acc[camel] = walk(obj[key]);
        return acc;
    }, {});
}

function camelCase(str) {
    return str.replace(/[_.-](\w|$)/g, function (_,x) {
        return x.toUpperCase();
    });
}

var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
};

var isDate = function (obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
};

var isRegex = function (obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var has = Object.prototype.hasOwnProperty;
var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

function map (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
    }
    return res;
}

function reduce (xs, f, acc) {
    if (xs.reduce) return xs.reduce(f, acc);
    for (var i = 0; i < xs.length; i++) {
        acc = f(acc, xs[i], i);
    }
    return acc;
}

},{}],35:[function(require,module,exports){
var nargs = /\{([0-9a-zA-Z]+)\}/g
var slice = Array.prototype.slice

module.exports = template

function template(string) {
    var args

    if (arguments.length === 2 && typeof arguments[1] === "object") {
        args = arguments[1]
    } else {
        args = slice.call(arguments, 1)
    }

    if (!args || !args.hasOwnProperty) {
        args = {}
    }

    return string.replace(nargs, function replaceArg(match, i, index) {
        var result

        if (string[index - 1] === "{" &&
            string[index + match.length] === "}") {
            return i
        } else {
            result = args.hasOwnProperty(i) ? args[i] : null
            if (result === null || result === undefined) {
                return ""
            }

            return result
        }
    })
}

},{}],36:[function(require,module,exports){
module.exports = extend

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],37:[function(require,module,exports){
var camelize = require("camelize")
var template = require("string-template")
var extend = require("xtend/mutable")

module.exports = TypedError

function TypedError(args) {
    if (!args) {
        throw new Error("args is required");
    }
    if (!args.type) {
        throw new Error("args.type is required");
    }
    if (!args.message) {
        throw new Error("args.message is required");
    }

    var message = args.message

    if (args.type && !args.name) {
        var errorName = camelize(args.type) + "Error"
        args.name = errorName[0].toUpperCase() + errorName.substr(1)
    }

    createError.type = args.type;
    createError._name = args.name;

    return createError;

    function createError(opts) {
        var result = new Error()

        Object.defineProperty(result, "type", {
            value: result.type,
            enumerable: true,
            writable: true,
            configurable: true
        })

        var options = extend({}, args, opts)

        extend(result, options)
        result.message = template(message, options)

        return result
    }
}


},{"camelize":34,"string-template":35,"xtend/mutable":36}],38:[function(require,module,exports){
module.exports=require(16)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-thunk.js":16}],39:[function(require,module,exports){
module.exports=require(17)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vhook.js":17}],40:[function(require,module,exports){
module.exports=require(18)
},{"./version":43,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vnode.js":18}],41:[function(require,module,exports){
module.exports=require(19)
},{"./version":43,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vtext.js":19}],42:[function(require,module,exports){
module.exports=require(20)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-widget.js":20}],43:[function(require,module,exports){
module.exports=require(21)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/version.js":21}],44:[function(require,module,exports){
var version = require("./version")
var isVNode = require("./is-vnode")
var isWidget = require("./is-widget")
var isVHook = require("./is-vhook")

module.exports = VirtualNode

var noProperties = {}
var noChildren = []

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName
    this.properties = properties || noProperties
    this.children = children || noChildren
    this.key = key != null ? String(key) : undefined
    this.namespace = (typeof namespace === "string") ? namespace : null

    var count = (children && children.length) || 0
    var descendants = 0
    var hasWidgets = false
    var descendantHooks = false
    var hooks

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName]
            if (isVHook(property)) {
                if (!hooks) {
                    hooks = {}
                }

                hooks[propName] = property
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i]
        if (isVNode(child)) {
            descendants += child.count || 0

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true
            }
        } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true
            }
        }
    }

    this.count = count + descendants
    this.hasWidgets = hasWidgets
    this.hooks = hooks
    this.descendantHooks = descendantHooks
}

VirtualNode.prototype.version = version
VirtualNode.prototype.type = "VirtualNode"

},{"./is-vhook":39,"./is-vnode":40,"./is-widget":42,"./version":43}],45:[function(require,module,exports){
var version = require("./version")

module.exports = VirtualText

function VirtualText(text) {
    this.text = String(text)
}

VirtualText.prototype.version = version
VirtualText.prototype.type = "VirtualText"

},{"./version":43}],46:[function(require,module,exports){
var classIdSplit = /([\.#]?[a-zA-Z0-9_:-]+)/
var notClassId = /^\.|#/

module.exports = parseTag

function parseTag(tag, props) {
    if (!tag) {
        return "div"
    }

    var noId = !("id" in props)

    var tagParts = tag.split(classIdSplit)
    var tagName = null

    if (notClassId.test(tagParts[1])) {
        tagName = "div"
    }

    var classes, part, type, i
    for (i = 0; i < tagParts.length; i++) {
        part = tagParts[i]

        if (!part) {
            continue
        }

        type = part.charAt(0)

        if (!tagName) {
            tagName = part
        } else if (type === ".") {
            classes = classes || []
            classes.push(part.substring(1, part.length))
        } else if (type === "#" && noId) {
            props.id = part.substring(1, part.length)
        }
    }

    if (classes) {
        if (props.className) {
            classes.push(props.className)
        }

        props.className = classes.join(" ")
    }

    return tagName ? tagName.toLowerCase() : "div"
}

},{}],47:[function(require,module,exports){
var attributeHook = require("./hooks/attribute-hook.js")
var h = require("./index.js")

var BLACKLISTED_KEYS = {
    "style": true,
    "namespace": true,
    "key": true
}
var SVG_NAMESPACE = "http://www.w3.org/2000/svg"

module.exports = svg

function svg(tagName, properties, children) {
    if (!children && isChildren(properties)) {
        children = properties
        properties = {}
    }

    properties = properties || {}

    // set namespace for svg
    properties.namespace = SVG_NAMESPACE

    // for each key, if attribute & string, bool or number then
    // convert it into a setAttribute hook
    for (var key in properties) {
        if (!properties.hasOwnProperty(key)) {
            continue
        }

        if (BLACKLISTED_KEYS[key]) {
            continue
        }

        var value = properties[key]
        if (typeof value !== "string" &&
            typeof value !== "number" &&
            typeof value !== "boolean"
        ) {
            continue
        }

        properties[key] = attributeHook(value)
    }

    return h(tagName, properties, children)
}

function isChildren(x) {
    return typeof x === "string" || Array.isArray(x)
}

},{"./hooks/attribute-hook.js":24,"./index.js":28}],48:[function(require,module,exports){
module.exports=require(17)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vhook.js":17}],49:[function(require,module,exports){
module.exports=require(18)
},{"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vnode.js":18}],50:[function(require,module,exports){
module.exports=require(19)
},{"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-vtext.js":19}],51:[function(require,module,exports){
module.exports=require(20)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/is-widget.js":20}],52:[function(require,module,exports){
module.exports=require(21)
},{"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/version.js":21}],53:[function(require,module,exports){
module.exports=require(44)
},{"./is-vhook":48,"./is-vnode":49,"./is-widget":51,"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-hyperscript/node_modules/vtree/vnode.js":44}],54:[function(require,module,exports){
module.exports=require(22)
},{"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-dom/node_modules/vtree/vpatch.js":22}],55:[function(require,module,exports){
module.exports=require(45)
},{"./version":52,"/home/shashi/.julia/v0.3/Patchwork/runtime/node_modules/virtual-hyperscript/node_modules/vtree/vtext.js":45}],56:[function(require,module,exports){
var nativeIsArray = Array.isArray
var toString = Object.prototype.toString

module.exports = nativeIsArray || isArray

function isArray(obj) {
    return toString.call(obj) === "[object Array]"
}

},{}],57:[function(require,module,exports){
isObject = require('is-object')

module.exports = {reorder: reorder,
                  patchObject: patchObject}

function reorder(array, moves) {
    if (!arr) { return }
    var copy = array.slice(0)

    for (var i=0, l=array.length; i < l; i++) {
        var move = moves[i]
        if (move !== undefined) {
            array[move] = copy[i]
        }
    }
    return array
}

function patchObject(obj, patch) {
    for (var key in patch) {
        if (patch[key] && typeof patch[key].hook == "function") {
            obj[key] = patch[key]
        } else if (isObject(patch[key]) && isObject(obj[key])) {
            obj[key] = patchObject(obj[key], patch[key]);
        } else {
            obj[key] = patch[key]
        }
    }
}


},{"is-object":4}],58:[function(require,module,exports){
var mutateNode = require("./vnode-patch-op")
var isArray = require('x-is-array')

module.exports = patchVNode

function patchVNode(root, patches) {

    linkParents(root)

    for (var key in patches) {
        if (key === "a") continue
        patch = patches[key]
        if (isArray(patch)) {

            for (var i=0, l=patch.length; i < l; i++) {
                mutateNode(patch[i].type, patch[i].vNode, patch[i].patch)
            }
        } else {
            mutateNode(patch.type, patch.vNode, patch.patch)
        }
    }

    return root
}

function linkParents(vNode) {
    if (!vNode || !vNode.children) { return }

    var children = vNode.children
    for (var i=0, l=children.length; i < l; i++) {
        children[i].up = vNode
        linkParents(children[i])
    }
}

},{"./vnode-patch-op":59,"x-is-array":56}],59:[function(require,module,exports){
var isWidget = require("vtree/is-widget")
var isVText = require("vtree/is-vtext")
var VPatch = require("vtree/vpatch")
var patchUtil = require("./patch-util.js")

module.exports = applyPatch

function applyPatch(type, vNode, patch) {

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(vNode)
        case VPatch.INSERT:
            return insertNode(vNode, patch)
        case VPatch.VTEXT:
            return stringPatch(vNode, patch)
        case VPatch.VNODE:
            return vNodePatch(vNode, patch)
        case VPatch.ORDER:
            patchUtil.reorder(vNode.children, patch)
            return vNode
        case VPatch.PROPS:
            patchUtil.patchObject(vNode.properties, patch)
            return vNode
        default:
            return vNode
    }
}

function offsetCount(node, count) {
    if (!node) { return }
    if (node.count !== undefined) {
        node.count = node.count + count
        offsetCount(node.up, count)
    } else {
        node.count = count
    }
}

function removeNode(node) {
    if (!node) { return }
    var count = node.count,
        up = node.up

    var idx = up.children.indexOf(node)
    if (idx > -1) {
        up.children.splice(idx, 1)
        var count = 0
        if (isVText(node)) {
            count = -1
        } else {
            count = -node.count - 1
        }
        offsetCount(up, count)
    }
    delete node

    return null
}

function insertNode(node, child) {
    node.children.push(child)
    var count = 0
    if (isVText(child)) {
        count = 1
    } else {
        count = child.count + 1
    }
    offsetCount(node, count)
    child.up = node
    return node
}

function stringPatch(node, patch) {
    node.text = patch.text
    return node
}

function vNodePatch(node, patch) {
    var up = node.up
    if (!up) {
        // copy over the patch to the root node
        for (key in patch) {
            if (!patch.hasOwnProperty(key)) continue
            node[key] = patch[key]
        }
        return
    }
    var idx = up.children.indexOf(node),
        count = patch.count || 0

    if (idx > -1) {
        up.children[idx] = patch
        if (node.count != count) {
            offsetCount(up, count - node.count)
        }
    }

    return node
}

},{"./patch-util.js":57,"vtree/is-vtext":50,"vtree/is-widget":51,"vtree/vpatch":54}],60:[function(require,module,exports){

},{}]},{},[1]);
</script><?xml version="1.0" encoding="utf-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="600" height="400" viewBox="0 0 600 400">
<defs>
  <clipPath id="clip8600">
    <rect x="0" y="0" width="600" height="400"/>
  </clipPath>
</defs>
<polygon clip-path="url(#clip8600)" points="
0,400 600,400 600,0 0,0 
  " fill="#ffffff" fill-opacity="1"/>
<defs>
  <clipPath id="clip8601">
    <rect x="120" y="0" width="421" height="400"/>
  </clipPath>
</defs>
<polygon clip-path="url(#clip8600)" points="
15.748,368.504 580.315,368.504 580.315,11.811 15.748,11.811 
  " fill="#ffffff" fill-opacity="1"/>
<defs>
  <clipPath id="clip8602">
    <rect x="15" y="11" width="566" height="358"/>
  </clipPath>
</defs>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:0.5; stroke-opacity:0.1; fill:none" points="
  106.263,368.504 106.263,11.811 
  "/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:0.5; stroke-opacity:0.1; fill:none" points="
  298.031,368.504 298.031,11.811 
  "/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:0.5; stroke-opacity:0.1; fill:none" points="
  489.8,368.504 489.8,11.811 
  "/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:0.5; stroke-opacity:0.1; fill:none" points="
  15.748,306.582 580.315,306.582 
  "/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:0.5; stroke-opacity:0.1; fill:none" points="
  15.748,226.055 580.315,226.055 
  "/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:0.5; stroke-opacity:0.1; fill:none" points="
  15.748,145.528 580.315,145.528 
  "/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:0.5; stroke-opacity:0.1; fill:none" points="
  15.748,65.0003 580.315,65.0003 
  "/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  15.748,368.504 580.315,368.504 
  "/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  15.748,368.504 15.748,11.811 
  "/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  106.263,368.504 106.263,363.154 
  "/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  298.031,368.504 298.031,363.154 
  "/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  489.8,368.504 489.8,363.154 
  "/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  15.748,306.582 24.2165,306.582 
  "/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  15.748,226.055 24.2165,226.055 
  "/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  15.748,145.528 24.2165,145.528 
  "/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  15.748,65.0003 24.2165,65.0003 
  "/>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:middle;" transform="rotate(0, 106.263, 382.304)" x="106.263" y="382.304">gross_primary_productivity</text>
</g>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:middle;" transform="rotate(0, 298.031, 382.304)" x="298.031" y="382.304">net_ecosystem_exchange</text>
</g>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:middle;" transform="rotate(0, 489.8, 382.304)" x="489.8" y="382.304">terrestrial_ecosystem_respiration</text>
</g>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:end;" transform="rotate(0, 9.74803, 311.082)" x="9.74803" y="311.082">0</text>
</g>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:end;" transform="rotate(0, 9.74803, 230.555)" x="9.74803" y="230.555">1</text>
</g>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:end;" transform="rotate(0, 9.74803, 150.028)" x="9.74803" y="150.028">2</text>
</g>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:end;" transform="rotate(0, 9.74803, 69.5003)" x="9.74803" y="69.5003">3</text>
</g>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:16; text-anchor:middle;" transform="rotate(0, 298.031, 397.6)" x="298.031" y="397.6">Variable</text>
</g>
<polygon clip-path="url(#clip8602)" points="
29.5554,266.928 29.5554,306.582 106.263,306.582 106.263,266.928 29.5554,266.928 29.5554,266.928 
  " fill="#009af9" fill-opacity="1"/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  29.5554,266.928 29.5554,306.582 106.263,306.582 106.263,266.928 29.5554,266.928 
  "/>
<polygon clip-path="url(#clip8602)" points="
221.324,286.151 221.324,306.582 298.031,306.582 298.031,286.151 221.324,286.151 221.324,286.151 
  " fill="#009af9" fill-opacity="1"/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  221.324,286.151 221.324,306.582 298.031,306.582 298.031,286.151 221.324,286.151 
  "/>
<polygon clip-path="url(#clip8602)" points="
413.093,243.713 413.093,306.582 489.8,306.582 489.8,243.713 413.093,243.713 413.093,243.713 
  " fill="#009af9" fill-opacity="1"/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  413.093,243.713 413.093,306.582 489.8,306.582 489.8,243.713 413.093,243.713 
  "/>
<polygon clip-path="url(#clip8602)" points="
106.263,11.811 106.263,306.582 182.97,306.582 182.97,11.811 106.263,11.811 106.263,11.811 
  " fill="#e26f46" fill-opacity="1"/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  106.263,11.811 106.263,306.582 182.97,306.582 182.97,11.811 106.263,11.811 
  "/>
<polygon clip-path="url(#clip8602)" points="
298.031,368.504 298.031,306.582 374.739,306.582 374.739,368.504 298.031,368.504 298.031,368.504 
  " fill="#e26f46" fill-opacity="1"/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  298.031,368.504 298.031,306.582 374.739,306.582 374.739,368.504 298.031,368.504 
  "/>
<polygon clip-path="url(#clip8602)" points="
489.8,74.7311 489.8,306.582 566.508,306.582 566.508,74.7311 489.8,74.7311 489.8,74.7311 
  " fill="#e26f46" fill-opacity="1"/>
<polyline clip-path="url(#clip8602)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  489.8,74.7311 489.8,306.582 566.508,306.582 566.508,74.7311 489.8,74.7311 
  "/>
<polygon clip-path="url(#clip8600)" points="
476.563,78.051 562.315,78.051 562.315,32.691 476.563,32.691 
  " fill="#ffffff" fill-opacity="1"/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  476.563,78.051 562.315,78.051 562.315,32.691 476.563,32.691 476.563,78.051 
  "/>
<polygon clip-path="url(#clip8600)" points="
482.563,53.859 518.563,53.859 518.563,41.763 482.563,41.763 482.563,53.859 
  " fill="#009af9" fill-opacity="1"/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  482.563,53.859 518.563,53.859 518.563,41.763 482.563,41.763 482.563,53.859 
  "/>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:start;" transform="rotate(0, 524.563, 52.311)" x="524.563" y="52.311">&lt; 7C</text>
</g>
<polygon clip-path="url(#clip8600)" points="
482.563,68.979 518.563,68.979 518.563,56.883 482.563,56.883 482.563,68.979 
  " fill="#e26f46" fill-opacity="1"/>
<polyline clip-path="url(#clip8600)" style="stroke:#000000; stroke-width:1; stroke-opacity:1; fill:none" points="
  482.563,68.979 518.563,68.979 518.563,56.883 482.563,56.883 482.563,68.979 
  "/>
<g clip-path="url(#clip8600)">
<text style="fill:#000000; fill-opacity:1; font-family:Arial,Helvetica Neue,Helvetica,sans-serif; font-size:12; text-anchor:start;" transform="rotate(0, 524.563, 67.431)" x="524.563" y="67.431">&gt;7C</text>
</g>
</svg>
<p>A second example would be that we want to calculate averages of the fluxes according to a country mask.</p><pre><code class="language-julia">import OnlineStats
vars  = [&quot;gross_primary_productivity&quot;,&quot;net_ecosystem_exchange&quot;,&quot;terrestrial_ecosystem_respiration&quot;]
m     = getCubeData(ds,variable=&quot;country_mask&quot;,longitude=lons,latitude=lats)
cube  = getCubeData(ds,variable=vars,longitude=lons,latitude=lats)

mT    = mapCube(OnlineStats.Mean,cube,by=[m,VariableAxis], cfun=splitTemp, outAxis=outAxis)</code></pre><p>This will split the cube by country and variable and compute averages over the input variables.</p><h3><a class="nav-anchor" id="Online-PCA-1" href="#Online-PCA-1">Online PCA</a></h3><p>It is possible to compute a principal component analysis based on a covariance matrix obtained through an online algorithm. The package provides a convenient way to achieve this with the cubePCA function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ESDL.Proc.DATOnlineStats.cubePCA" href="#ESDL.Proc.DATOnlineStats.cubePCA"><code>ESDL.Proc.DATOnlineStats.cubePCA</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cubePCA(cube::AbstractCubeData)</code></pre><p>Performs a PCA based on a covariance matrix which is estimated through an online algorithm. Returns an OnlinePCA object from which <a href="@ref"><code>explained_variance</code></a> and the <a href="@ref"><code>rotation</code></a> can be extracted, or which can be used to perform the projection on a dataset.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>MDAxis</code> specifies the axes that is reduced through the PCA</p></li><li><p><code>by</code> a vector of axes types or masks denoting if several PCAs should be performed. If provided, several PCAs will be performed.</p></li><li><p><code>noutdims</code> number of output dimensions, how many PCs are estimated</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/esa-esdl/ESDL.jl/blob/38e504a8c7d5c0b5f1cd18c500df728b224923d2/src/Proc/Online/OnlinePCA.jl#L105-L118">source</a></section><p>For example, if one wants to calculate a PCA over the time dimension, you could use the following code:</p><h3><a class="nav-anchor" id="Online-Histograms-and-quantiles-1" href="#Online-Histograms-and-quantiles-1">Online Histograms and quantiles</a></h3><p>It is possible to estimate histograms and quantiles of larger-than-memory datasets using an adaptive-bin histogram algorithm. The <code>Base.quantile</code> method is overloaded for objects of type <code>AbstractCubeData</code>, so the following works:</p><pre><code class="language-julia">c=Cube()
d=getCubeData(c,variable=[&quot;gross_primary_productivity&quot;,&quot;net_ecosystem_exchange&quot;], region=&quot;Europe&quot;)
q = quantile(d,[0.1,0.9], by=[VariableAxis])
q.data</code></pre><pre><code class="language-none">2×2 Array{Float32,2}:
 0.040161  -1.88354
 6.02323    0.552485</code></pre><p>to estimate the 10% and 90% quantiles of all datapoints for each variable. Note that any additional keyword arguments to this call (like the <code>by</code> argument) are passed to the respective <code>mapCube</code> call.</p><footer><hr/><a class="previous" href="cube_access.html"><span class="direction">Previous</span><span class="title">Accessing the Data Cube</span></a><a class="next" href="plotting.html"><span class="direction">Next</span><span class="title">Plotting</span></a></footer></article></body></html>
