module DAT
export @registerDATFunction, joinVars, DATdir, mapDAT
importall ..Cubes
importall ..CubeAPI
importall ..CubeAPI.CachedArrays
importall ..CABLABTools
importall ..Cubes.TempCubes
import ...CABLAB
using Base.Dates
global const workdir=UTF8String["./"]
global const debugDAT=true

haskey(ENV,"CABLAB_WORKDIR") && (workdir[1]=ENV["CABLAB_WORKDIR"])

DATdir(x::AbstractString)=workdir[1]=x
DATdir()=workdir[1]

"""
Configuration object of a DAT process. This holds all necessary information to perform the calculations
It contains the following fields:

- `incubes::Vector{AbstractCubeData}` The input data cubes
- `outcube::AbstractCubeData` The output data cube
- `indims::Vector{Tuple}` Tuples of input axis types
- `outdims::Tuple` Tuple of output axis types
- `axlists::Vector{Vector{CubeAxis}}` Axes of the input data cubes
- inAxes::Vector{Vector{CubeAxis}}
- outAxes::Vector{CubeAxis}
- LoopAxes::Vector{CubeAxis}
- axlistOut::Vector{CubeAxis}
- ispar::Bool
- isMem::Vector{Bool}
- inCubesH
- outCubeH

"""
type DATConfig
  NIN           :: Int
  incubes       :: Vector
  outcube       :: AbstractCubeData
  indims        :: Vector
  outdims       :: Tuple
  axlists       :: Vector #Of vectors
  inAxes        :: Vector #Of vectors
  broadcastAxes :: Vector #Of Vectors
  outAxes       :: Vector
  LoopAxes      :: Vector
  axlistOut     :: Vector
  ispar         :: Bool
  isMem         :: Vector{Bool}
  inCacheSizes  :: Vector #of vectors
  loopCacheSize :: Vector{Int}
  inCubesH
  outCubeH
  max_cache
  outfolder
  sfu
  addargs
end
DATConfig(incubes,indims,outdims,outtype,max_cache,outfolder,sfu,addargs)=DATConfig(length(incubes),AbstractCubeData[c for c in incubes],EmptyCube{outtype}(),collect(indims),outdims,Vector{CubeAxis}[],Vector{CubeAxis}[],
  Vector{Int}[],CubeAxis[],CubeAxis[],CubeAxis[],nprocs()>1,map(x->isa(x,AbstractCubeMem),incubes),Vector{Int}[],Int[],[],[],max_cache,outfolder,sfu,addargs)
DATConfig(incubes::AbstractCubeData,indims,outdims,outtype,max_cache,outfolder,sfu,addargs)=DATConfig([incubes;],indims,outdims,outtype,max_cache,outfolder,sfu,addargs)


"""
Object to pass to InnerLoop, this condenses the most important information about the calculation into a type so that
specific code can be generated by the @generated function
"""
immutable InnerObj{NIN,T1,T2,T3} end
function InnerObj(dc::DATConfig)
  T1=totuple(map(length,dc.inAxes))
  T2=length(dc.outAxes)
  T3=totuple(map(totuple,dc.broadcastAxes))
  InnerObj{dc.NIN,T1,T2,T3}()
end


const fdimsin=Dict{UTF8String,Tuple}()
const fdimsout=Dict{UTF8String,Tuple}()
const fargs=Dict{UTF8String,Tuple}()
const fncubes=Dict{UTF8String,Tuple}()

function Base.map(fu::Function,cdata::Union{Vector{AbstractCubeData},AbstractCubeData},addargs...;max_cache=1e7,outfolder=joinpath(workdir[1],string(tempname()[2:end],fu)),
  sfu=split(string(fu),".")[end],indims=fdimsin[sfu],outdims=fdimsout[sfu],outtype=isa(cdata,Vector) ? eltype(cdata[1]) : eltype(cdata))

  isdir(outfolder) || mkpath(outfolder)

  dc=DATConfig(cdata,indims,outdims,outtype,max_cache,outfolder,sfu,addargs)

  reOrderInCubes(dc)

  analyzeAxes(dc)

  getCacheSizes(dc)

  generateOutCube(dc)

  getCubeHandles(dc)

  runLoop(dc)

  return dc.outcube

end

function mustReorder(cdata,indims)
  reorder=false
  axlist=axes(cdata)
  for (i,fi) in enumerate(indims)
    typeof(axlist[i])==fi || (reorder=true)
  end
  reorder
end

function reOrderInCubes(dc::DATConfig)
  cdata=dc.incubes
  indims=dc.indims
  for i in eachindex(cdata)
    if mustReorder(cdata[i],indims[i])
      perm=getFrontPerm(cdata[i],indims[i])
      cdata[i]=permutedims(cdata[i],perm)
    end
    push!(dc.axlists,axes(cdata[i]))
  end
end

function runLoop(dc::DATConfig)
  if dc.ispar
    allRanges=distributeLoopRanges(dc.outcube.block_size.I[(end-length(dc.LoopAxes)+1):end],map(length,dc.LoopAxes))
    pmap(r->CABLAB.DAT.innerLoop(Val{Symbol(Main.PMDATMODULE.dc.sfu)},CABLAB.CABLABTools.totuple(Main.PMDATMODULE.dc.inCubesH),
      Main.PMDATMODULE.dc.outCubeH[1],CABLAB.DAT.InnerObj(Main.PMDATMODULE.dc),r,Main.PMDATMODULE.dc.addargs),allRanges)
    isa(dc.outcube,TempCube) && @everywhereelsem CachedArrays.sync(dc.outCubeH[1])
  else
    innerLoop(Val{Symbol(dc.sfu)},totuple(dc.inCubesH),dc.outCubeH[1],InnerObj(dc),totuple(map(length,dc.LoopAxes)),dc.addargs)
    isa(dc.outCubeH[1],CachedArray) && CachedArrays.sync(dc.outCubeH[1])
  end
  dc.outcube
end

function generateOutCube(dc::DATConfig)
  T=eltype(dc.outcube)
  outsize=sizeof(T)*prod(map(length,dc.axlistOut))
  if outsize>dc.max_cache || dc.ispar
    dc.outcube=TempCube(dc.axlistOut,CartesianIndex(totuple([map(length,dc.outAxes);dc.loopCacheSize])),folder=dc.outfolder,T=T)
  else
    newsize=map(length,dc.axlistOut)
    dc.outcube = Cubes.CubeMem{T,length(newsize)}(dc.axlistOut, zeros(T,newsize...),zeros(UInt8,newsize...))
  end
end

dcg=nothing
function getCubeHandles(dc::DATConfig)
  if dc.ispar
    global dcg=dc
    try
      passobj(1, workers(), [:dcg],from_mod=CABLAB.DAT,to_mod=Main.PMDATMODULE)
    end
    @everywhereelsem begin
      dc=Main.PMDATMODULE.dcg
      tc=openTempCube(dc.outfolder)
      push!(dc.outCubeH,CachedArray(tc,1,tc.block_size,MaskedCacheBlock{eltype(tc),length(tc.block_size.I)}))
      for icube=1:dc.NIN
        if dc.isMem[icube]
          push!(dc.inCubesH,dc.incubes[icube])
        else
          push!(dc.inCubesH,CachedArray(dc.incubes[icube],1,CartesianIndex(totuple(dc.inCacheSizes[icube])),MaskedCacheBlock{eltype(dc.incubes[icube]),length(dc.axlists[icube])}))
        end
      end
    end
  else
    # For one-processor operations
    for icube=1:dc.NIN
      if dc.isMem[icube]
        push!(dc.inCubesH,dc.incubes[icube])
      else
        push!(dc.inCubesH,CachedArray(dc.incubes[icube],1,CartesianIndex(totuple(dc.inCacheSizes[icube])),MaskedCacheBlock{eltype(dc.incubes[icube]),length(dc.axlists[icube])}))
      end
    end
    if isa(dc.outcube,TempCube)
      push!(dc.outCubeH,CachedArray(dc.outcube,1,dc.outcube.block_size,MaskedCacheBlock{eltype(dc.outcube),length(dc.axlistOut)}))
    else
      push!(dc.outCubeH,dc.outcube)
    end
  end
end

function init_DATworkers()
  freshworkermodule()
end

function run_disk_par(cdata::AbstractCubeData, T, axlist, inAxes, outAxes,LoopAxes, max_cache, indims, loopinR, loopOutR, loopR, axlistOut, outfolder,sfu,addargs)

  tc=TempCube(axlistOut,CartesianIndex(totuple([map(length,outAxes);loopCacheSize])),folder=outfolder)
  global myExchangeObj
  myExchangeObj=(outfolder,T,cdata,CacheInSize,axlist,sfu,loopinR,loopOutR,addargs)
  try
    passobj(1, workers(), [:myExchangeObj],from_mod=CABLAB.DAT,to_mod=Main.PMDATMODULE)
  end

  @everywhereelsem tc=openTempCube(outfolder)
  @everywhereelsem tca=CachedArray(tc,1,tc.block_size,MaskedCacheBlock{T,length(tc.block_size.I)});
  @everywhereelsem cm=CachedArray(cdata,1,CartesianIndex(totuple(CacheInSize)),MaskedCacheBlock{T,length(axlist)});
  allRanges=distributeLoopRanges(tc.block_size.I[(end-length(loopR)+1):end],loopR)
  pmap(r->innerLoop(Val{Symbol(sfu)},Main.PMDATMODULE.cm,Main.PMDATMODULE.tca,CABLAB.DAT.totuple(Main.PMDATMODULE.loopinR),CABLAB.DAT.totuple(Main.PMDATMODULE.loopOutR),r,Main.PMDATMODULE.addargs),allRanges)
  @everywhereelsem CachedArrays.sync(tca)
  tc
end

function run_disk_one(cdata::AbstractCubeData, T, axlist, inAxes, outAxes,LoopAxes, max_cache, indims, loopinR, loopOutR, loopR, axlistOut,outfolder,sfu,addargs)

  tc=TempCube(axlistOut,CartesianIndex(totuple([map(length,outAxes);loopCacheSize])),folder=outfolder)
  tca=CachedArray(tc,1,tc.block_size,MaskedCacheBlock{T,length(axlistOut)});
  cm=CachedArray(cdata,1,CartesianIndex(totuple(CacheInSize)),MaskedCacheBlock{T,length(axlist)});
  innerLoop(Val{Symbol(sfu)},cm,tca,totuple(loopinR),totuple(loopOutR),totuple(loopR),addargs)
  CachedArrays.sync(tca)
  tc
end

function run_mem_one(cdata::AbstractCubeData, T, axlist, inAxes, outAxes,LoopAxes, max_cache, indims, loopinR, loopOutR, loopR, axlistOut,outfolder,sfu,addargs)

  newsize=map(length,axlistOut)
  outCube = Cubes.CubeMem{T,length(newsize)}(axlistOut, zeros(T,newsize...),zeros(UInt8,newsize...))
  innerLoop(Val{Symbol(sfu)},cdata,outCube,totuple(loopinR),totuple(loopOutR),totuple(loopR),addargs)
  outCube
end

function analyzeAxes(dc::DATConfig)
  for icube=1:dc.NIN
    push!(dc.inAxes,CubeAxis[])
    for a in dc.axlists[icube]
      in(typeof(a),dc.indims[icube]) ?  push!(dc.inAxes[icube],a) : push!(dc.LoopAxes,a)
      in(typeof(a),dc.outdims)       && push!(dc.outAxes,a)
    end
  end
  dc.axlistOut=CubeAxis[dc.outAxes;dc.LoopAxes]
  for icube=1:dc.NIN
    push!(dc.broadcastAxes,Int[])
    for iLoopAx=1:length(dc.LoopAxes)
      !in(typeof(dc.LoopAxes[iLoopAx]),map(typeof,dc.axlists[icube])) && push!(dc.broadcastAxes[icube],iLoopAx)
    end
  end
  return dc
end

function getCacheSizes(dc::DATConfig)

  if all(dc.isMem)
    dc.inCacheSizes=[Int[] for i=1:dc.NIN]
    dc.loopCacheSize=Int[]
    return dc
  end
  inAxlengths      = [map(length,dc.inAxes[i]) for i=1:length(dc.inAxes)]
  inblocksizes     = map((x,T)->prod(x)*sizeof(eltype(T)),inAxlengths,dc.incubes)
  inblocksize,imax = findmax(inblocksizes)
  outblocksize     = length(dc.outAxes)>0 ? sizeof(eltype(dc.outcube))*prod(map(length,dc.outAxes)) : 1
  loopCacheSize    = getLoopCacheSize(max(inblocksize,outblocksize),dc.LoopAxes,dc.max_cache)
  for icube=1:dc.NIN
    if dc.isMem[icube]
      push!(dc.inCacheSizes,Int[])
    else
      push!(dc.inCacheSizes,map(length,dc.inAxes[icube]))
      for iLoopAx=1:length(dc.LoopAxes)
        in(typeof(dc.LoopAxes[iLoopAx]),map(typeof,dc.axlists[icube])) && push!(dc.inCacheSizes[icube],loopCacheSize[iLoopAx])
      end
    end
  end
  dc.loopCacheSize=loopCacheSize
  return dc
end

"Calculate optimal Cache size to DAT operation"
function getLoopCacheSize(preblocksize,LoopAxes,max_cache)
  totcachesize=max_cache

  incfac=totcachesize/preblocksize
  incfac<1 && error("Not enough memory, please increase availabale cache size")
  loopCacheSize = ones(Int,length(LoopAxes))
  for iLoopAx=1:length(LoopAxes)
    s=length(LoopAxes[iLoopAx])
    if s<incfac
      loopCacheSize[iLoopAx]=s
      incfac=incfac/s
      continue
    else
      ii=floor(Int,incfac)
      while ii>1 && rem(s,ii)!=0
        ii=ii-1
      end
      loopCacheSize[iLoopAx]=ii
      break
    end
  end
  return loopCacheSize
  j=1
  CacheInSize=Int[]
  for a in axlist
    if typeof(a) in indims
      push!(CacheInSize,length(a))
    else
      push!(CacheInSize,loopCacheSize[j])
      j=j+1
    end
  end
  @assert j==length(loopCacheSize)+1
  CacheOutSize = [map(length,outAxes);loopCacheSize]
  return CacheInSize, CacheOutSize
end

using Base.Cartesian
@generated function distributeLoopRanges{N}(block_size::NTuple{N,Int},loopR::Vector)
    quote
        @assert length(loopR)==N
        nsplit=Int[div(l,b) for (l,b) in zip(loopR,block_size)]
        baseR=UnitRange{Int}[1:b for b in block_size]
        a=Array(NTuple{$N,UnitRange{Int}},nsplit...)
        @nloops $N i a begin
            rr=@ntuple $N d->baseR[d]+(i_d-1)*block_size[d]
            @nref($N,a,i)=rr
        end
        a=reshape(a,length(a))
    end
end

using Base.Cartesian
@generated function innerLoop{fT,T1,T2,T3,T4,NIN}(::Type{Val{fT}},xin,xout,::InnerObj{NIN,T1,T2,T4},loopRanges::T3,addargs)
  NinCol      = T1
  NoutCol     = T2
  broadcastvars = T4
  Nloopvars   = length(T3.parameters)
  loopRangesE = Expr(:block)
  subIn=[Expr(:call,:(CachedArrays.getSubRange),:(xin[$i]),fill(:(:),NinCol)...) for i=1:NIN]
  subOut=Expr(:call,:(CachedArrays.getSubRange),:xout,fill(:(:),NoutCol)...)
  for i=1:Nloopvars
    isym=Symbol("i_$(i)")
    for j=1:NIN
      in(i,broadcastvars[j]) || push!(subIn[j].args,isym)
    end
    push!(subOut.args,isym)
    if T3.parameters[i]==UnitRange{Int}
      unshift!(loopRangesE.args,:($isym=loopRanges[$i]))
    elseif T3.parameters[i]==Int
      unshift!(loopRangesE.args,:($isym=1:loopRanges[$i]))
    else
      error("Wrong Range argument")
    end
  end
  push!(subOut.args,Expr(:kw,:write,true))
  loopBody=quote
    aout,mout=$subOut
  end
  callargs=Any[:(Main.$(fT)),:aout,:mout]
  for (i,s) in enumerate(subIn)
    ains=symbol("ain_$i");mins=symbol("min_$i")
    push!(loopBody.args,:(($(ains),$(mins))=$s))
    push!(callargs,ains)
    push!(callargs,mins)
  end
  push!(callargs,Expr(:...,:addargs))
  push!(loopBody.args,Expr(:call,callargs...))
  println(Expr(:for,loopRangesE,loopBody))
  return Expr(:for,loopRangesE,loopBody)
end

macro registerDATFunction(fname, dimsin,dimsout,args...)
    @assert dimsin.head==:tuple
    @assert dimsout.head==:tuple
    sfname=isa(esc(fname),Symbol) ? string(esc(fname)) : string(esc(fname).args[end])
    quote
        fdimsin[$sfname]=($dimsin,)
        fdimsout[$sfname]=$dimsout
        fargs[$sfname]=$args
    end
end

macro registerDATFunctionN(fname,N,dimsin,dimsout,args...)
    @assert isa(N,Int)
    @assert dimsin.head==:tuple
    @assert length(dimsin.args)==N
    @assert dimsout.head==:tuple
    sfname=isa(esc(fname),Symbol) ? string(esc(fname)) : string(esc(fname).args[end])
    quote
        fdimsin[$sfname]=$dimsin
        fdimsout[$sfname]=$dimsout
        fargs[$sfname]=$args
        fncubes[$sfname]=$N
    end
end


"Find a certain axis type in a vector of Cube axes"
function findAxis{T<:CubeAxis}(a::Type{T},v)
    for i=1:length(v)
        isa(v[i],a) && return i
    end
    return 0
end

"Calculate an axis permutation that brings the wanted dimensions to the front"
function getFrontPerm{T}(dc::AbstractCubeData{T},dims)
  ax=axes(dc)
  N=length(ax)
  perm=Int[i for i=1:length(ax)];
  iold=Int[]
  for i=1:length(dims) push!(iold,findAxis(dims[i],ax)) end
  iold2=sort(iold,rev=true)
  for i=1:length(iold) splice!(perm,iold2[i]) end
  perm=Int[iold;perm]
  return ntuple(i->perm[i],N)
end



end
